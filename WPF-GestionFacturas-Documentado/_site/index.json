{
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | mysite",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | mysite",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | mysite",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "packages/Azure.Core.1.47.1/CHANGELOG.html": {
    "href": "packages/Azure.Core.1.47.1/CHANGELOG.html",
    "title": "Release History | mysite",
    "summary": "Release History 1.47.1 (2025-07-15) Features Added Adopt System.ClientModel 1.5.1 1.47.0 (2025-07-09) Features Added Added RequestContent.Create<T>(T model, ModelReaderWriterOptions? options = null) overload that accepts IPersistableModel<T> types for improved performance and API consistency with BinaryContent. Adopt System.ClientModel 1.5.0 Other Changes Adjusted the options used for JSON serialization to relax encoding rules and reduce the cost and impact. (#50885) 1.46.2 (2025-06-05) Features Added Adopt System.ClientModel 1.4.2 1.46.1 (2025-05-09) Features Added Adopt System.ClientModel 1.4.1 1.46.0 (2025-05-06) Features Added Adding AzureCoreContext to support AOT compatible reading and writing of types owned by Azure.Core through ModelReaderWriter 1.45.0 (2025-02-11) Acknowledgments Thank you to our developer community members who helped to make the Azure.Core library better with their contributions to this release: Jero Bado (GitHub) Features Added Added MexicoCentral and SpainCentral locations to AzureLocation struct. This was a community contribution, courtesy of jerobado. (#47862) Bugs Fixed Fixed an issue where BearerTokenAuthenticationPolicy throws ArgumentOutOfRangeException if the ExpiresOn property of the token is the default value. (#47040) Other Changes Use BinaryData.Empty for PipelineResponse.Content when HTTP message has no content. 1.44.1 (2024-10-09) Other Changes Upgraded System.Text.Json package dependency to 6.0.10 for security fix (#46134). 1.44.0 (2024-10-03) Features Added TokenRequestContext added the IsProofOfPossessionEnabled, ResourceRequestMethod, and ResourceRequestUri properties to support Proof of Possession tokens (45134). AccessToken added the TokenType property to support distinguishing Bearer tokens from Proof of Possession (PoP) tokens (45134). Moved implementation of Azure.AzureKeyCredential into System.ClientModel.ApiKeyCredential and made ApiKeyCredential the base type for AzureKeyCredential (#46128). BearerTokenAuthenticationPolicy now will attempt to handle Continuous Access Evaluation (CAE) challenges, if present, by default (#46277). Other Changes Upgraded System.Memory.Data package dependency to 6.0.0 (#46134). 1.43.0 (2024-09-12) Other Changes Upgraded System.Text.Json package dependency to 6.0.9 (#45416). Added a new constructor on AzureEventSourceListener for callers that don't need the formatted message (#45191). Remove unused callback from HttpRequestMessage options in HttpClientTransport transport (#45696). Added RequiresUnreferencedCode and RequiresDynamicCode attributes to ToDynamicFromJson extension methods and DynamicData APIs to support AOT scenarios (#45417). 1.42.0 (2024-08-01) Other Changes Improved memory performance for Event Source formatting #43947 Upgraded dependency on System.Text.Encodings.Web to 6.0.0 Upgraded dependency on Microsoft.Bcl.AsyncInterfaces to 6.0.0 1.41.0 (2024-07-11) Bugs Fixed Fixed an issue that could result in BearerTokenAuthenticationPolicy fails to refresh a token, resulting in a OperationCanceledException (#44882). Fixed case where a GeoJSON string could not be deserialized when the BoundingBox JSON value (\"bbox\") was set explicitly to null (#44835). 1.40.0 (2024-06-06) Features Added Added RefreshOn property to AccessToken and updated BearerTokenAuthenticationPolicy to refresh long-lived credentials according to this value (#43836). Bugs Fixed Fixed User-Agent telemetry so that it properly escapes operating system information if it contains non-ascii characters (#44386). Fixed case where Operation.Id was not being set for incomplete long-running operations (#44098). Other Changes Improved memory performance for HTTP message sanitization (#43818). Added DynamicallyAccessedMembers attribute to type parameter in Operation<T>.Rehydrate method (#44208). 1.39.0 (2024-04-18) Features Added Add Operation.Rehydrate and Operation.Rehydrate<T> static methods to rehydrate a long-running operation. Other Changes RequestFailedException will not include the response content or headers in the message when the IsError property of the response is false. 1.38.0 (2024-02-26) Features Added Add GetRehydrationToken to Operation for rehydration purpose. Other Changes Additional Azure data centers are now included in AzureLocation. The following were added: China East 3 China North 3 Israel Central Italy North Poland Central Sweden South 1.37.0 (2024-01-11) Bugs Fixed Fixed exponential retry behavior so that delay milliseconds greater than Int32.MaxValue do not trigger an exception. Fixed DelayStrategy behavior to no longer shift the delay to be used over by one attempt. Previously, the first delay would be what should have been used for the second, and the second was what should have been used for the third, etc. Note, this would only be observed when using DelayStrategy outside of a RetryPolicy or RetryOptions. Do not add the error.type attribute twice when tracing is enabled. Do not suppress nested activities when they occur in the context of Consumer/Server activities (e.g. BlobClient.Download is no longer suppressed under EventHubs.Process). Other Changes Remove targets for .NET Core 2.1 and .NET 5 since they are out of support. Azure.Core is no longer compatible with .NET Core 2.1 after removal of target. The remaining targets are unchanged. 1.36.0 (2023-11-10) Features Added Added RequiresUnreferencedCode attribute to RequestContent.Create(object) overloads that use reflection to serialize the input object. This provides support for native AOT compilation when Azure.Core is used for diagnostics. Use System.Text.Json source generation to deserialize the error response in RequestFailedException on net6.0 and above targets. Breaking Changes Updated tracing attributes names to conform to OpenTelemetry semantic conventions version 1.23.0. Suppress client activity creation by Azure clients if it happens in scope of another activity created by an Azure client. Changed how ActivitySource name is constructed for clients that use single-worded activity names (without dot). We now append provided activity name as is to the client namespace name. Previously, the provided activity name was omitted and the ActivitySource name matched the provided client namespace. Distributed tracing with ActivitySource for HTTP and REST-based client libraries is declared stable. Experimental feature-flag is no longer required for most of the newly released libraries. Tracing for messaging libraries remains experimental. Added nullable annotation to ResourceIdentifier.TryParse parameter input. 1.35.0 (2023-09-07) Features Added Expand the set of supported DynamicData property types to included heterogeneous arrays of allowed types. Breaking Changes Added the nullability annotation to NullableResponse<T>.Value to indicate that it is a nullable type. 1.34.0 (2023-07-11) Features Added Added IsCaeEnabled property to TokenRequestContext to enabled per-request support for Continuous Access Evaluation Updated dependency on System.Diagnostics.DiagnosticSource Added ContentLengthLong property to ResponseHeaders 1.33.0 (2023-06-16) Features Added Added BinaryData.ToDynamicFromJson() extension method to enable dynamic access to JSON. See the aka.ms/azsdk/net/dynamiccontent for further details. Other Changes Client redirects are now disabled by default and can be enabled by setting providing a custom transport in ClientOptions'. Client Authors can also enable redirects by setting HttpPipelineTransportOptions.IsClientRedirectEnabledtotrueon the transport options passed toHttpPipelineBuilder.Build`. 1.32.0 (2023-05-09) Features Added Added the GetRawResponse method to RequestFailedException. Added overloads of Operation<T>.WaitForCompletion and Operation.WaitForCompletionResponse that take a DelayStrategy. 1.31.0 (2023-04-10) Features Added Added the RetryPolicy type which can be used to create a custom retry policy. Added the DelayStrategy type which can be used to customize delays. Bugs Fixed Set the Activity status to Error on failed activity source activities. Mark the Azure.Core.Http.Request span as failed if the request fails with an exception thrown in the pipeline. Fixed equality comparison when comparing a string to a ContentType instance. Jitter is added when using a RetryMode of Fixed. 1.30.0 (2023-03-09) Bugs Fixed Fixed the issue with empty header names and values, caused by ArrayBackedPropertyBag keeping reference to the array after returning it to array pool in Dispose method. 1.29.0 (2023-03-02) Features Added ActivitySource activities that are used when using the experimental OpenTelemetry support will include the az.schema_url tag indicating the OpenTelemetry schema version. They will also include the attribute names specified here. \"West US 3\", \"Sweden Central\" and \"Qatar Central\" locations are added to Azure.Core.AzureLocation Improvements Azure.Core.ArrayBackedPropertyBag is used to store request headers before HttpRequestMessage is created instead of System.Net.Http.Headers.HttpContentHeaders Azure.HttpRange.ToString uses string.Create instead of FormattableString.Invariant in .NET 6.0+ Azure.Core.Diagnostics.AzureCoreEventSource checks EventLevel before formatting data for the events Azure.Core.Pipeline.HttpClientTransport.JoinHeaderValues uses System.Runtime.CompilerServices.DefaultInterpolatedStringHandler to join header string values in .NET 6.0+ Bugs Fixed ActivitySource activities will no longer be stamped with the kind attribute as this is redundant with the OpenTelemetry SpanKind attribute. The product information section of the UserAgent header is now validated for invalid parenthesis formatting and escaped, if necessary. 1.28.0 (2023-02-06) Bugs Fixed Fixed an issue with AzureSasCredential which resulted in messages to fail authentication if the SAS signature was updated while a message was in a retry cycle. 1.27.0 (2023-01-10) Features Added Made RedirectPolicy public to provide SetAllowAutoRedirect() method to library authors. Added RetryPolicy property to ClientOptions to allow library authors to set a custom retry policy. Added MessageProcessingContext type and ProcessingContext property to HttpMessage which contains information about the message as it traverses through the pipeline. Added SetProperty and TryGetProperty overloads to HttpMessage to allow setting property values using a Type as the key. 1.26.0 (2022-11-08) Features Added Introduced a new NullableResponse<T> type for scenarios where a service method may or may not return a value. One common example is Get*IfExists methods. Response<T> also now inherits from NullableResponse<T>. Added TryParse method to the ResourceIdentifier type. Added AppendQuery and AppendPath overloads to RequestUriBuilder. Bugs Fixed Fixed issue where fixed delay was applied when the RetryMode was set to Exponential when retrying a request that resulted in an exception. Other Changes Azure.Core now targets .NET 6 in addition to the existing targets. 1.25.0 (2022-06-23) Features Added Added RequestFailedDetailsParser abstract class, which client libraries can implement to control customization of exception messages for failed responses. Added HttpPipelineOptions type which is accepted in a new overload to HttpPipelineBuilder.Build. This type contains all the properties from other overloads and adds a property to specify a RequestFailedDetailsParser. Added a property to HttpPipelineTransportOptions called ClientCertificates which is a collection of X509Certificate2. If populated, the certificates in the collection will be used by the client for TLS client certificate authentication. Added the MultipartResponse type, which can be used by clients to parse the sub-responses for multi-part responses. 1.24.0 (2022-04-04) Features Added Added the MessageContent type which represents a message containing a content type and data. Sub classes of ClientOptions are now able to create sub class implementations of DiagnosticsOptions and set it as the implementation for the Diagnostics property of ClientOptions via a new constructor overload. 1.23.0 (2022-03-21) Features Added Added the TelemetryDetails type which enables customization of UserAgent header values on a per-request basis based on a specified Assembly and an optional application Id string. Added AddClassifier methods to RequestContext. These methods allow callers to change the response classification behavior for a given method invocation. Added a new StatusCodeClassifier type that will be used as the default ResponseClassifier for some libraries. Added an extension method to BinaryData called ToObjectFromJson which converts the json value represented by BinaryData to an object of a specific type. Additional data center locations were added to AzureLocation. Added WaitUntil enum to allow callers to set whether a method invoking a long running operation should return when the operation starts or once it has completed. Breaking Changes Cookies are no longer set on requests by default. Cookies can be re-enabled for HttpClientTransport by either setting an AppContext switch named \"Azure.Core.Pipeline.HttpClientTransport.EnableCookies\" to true or by setting the environment variable, \"AZURE_CORE_HTTPCLIENT_ENABLE_COOKIES\" to \"true\". Note: AppContext switches can also be configured via configuration like below: <ItemGroup> <RuntimeHostConfigurationOption Include=\"Azure.Core.Pipeline.HttpClientTransport.EnableCookies\" Value=\"true\" /> </ItemGroup> 1.22.0 (2022-01-11) Features Added Added AddPolicies method to RequestContext. This allows policies to be added to the pipeline when calling protocol methods. Added IsError property to Response. This will indicate whether the message's ResponseClassifier considers the response to be an error. Added RequestFailedException constructor that takes a Response. Added AzureLocation. This class gives static references to known Azure regions. Added ResourceIdentifier. This class allows users to load an Azure resource identifier string and parse out the pieces of that string such as which SubscriptionId does the resource belong to. Added ResourceType. This class represents the ARM provider information for a given resource and is used by the ResourceIdentifier class. Added HttpPipelineTransportOptions type. This type contains a ServerCertificateCustomValidationCallback property that allows callers to set a Func<ServerCertificateCustomValidationArgs, bool> delegate. If set, the delegate will be called to validate the server side TLS certificate. Added a new static overload for HttpPipelineBuilder.Build that takes an HttpPipelineTransportOptions instance. This overload creates an HttpPipeline with the default transport configuration and the HttpPipelineTransportOptions applied. It returns a DisposableHttpPipeline that implements IDisposable. Note: The HttpPipelineTransportOptions will not be applied if a custom Transport has been set in the ClientOptions. In the case that transport options were provided but not applied, an event is logged (PipelineTransportOptionsNotApplied). Breaking Changes Added logging of api-version query parameter by default. In order to redact this, you can do the following: options.Diagnostics.LoggedQueryParameters.Remove(\"api-version\"); Bugs Fixed Fixed a bug where requests were failing with NotImplementedException on Unity with .NET Framework scripting. 1.21.0 (2021-11-03) Features Added Added RequestContext and ErrorOptions types to aid in configuring requests. Added ContentType strongly-typed string to allow operation callers to specify the content type of a request. 1.20.0 (2021-10-01) Features Added Added the static DelegatedTokenCredential type with a Create method, which returns an instance of TokenCredential that uses the supplied delgates to produce an AccessToken. This would most typically be used when an token has previously been obtained from some other source and that token needs to be returned by a TokenCredential instance. Added ResponseError type to represent an Azure error type. Added an experimental ActivitySource support. Bugs Fixed Fixed an exception during EventSource creation on Xamarin. 1.19.0 (2021-09-07) Features Added Added HttpAuthorization to represent authentication information in Authorization, ProxyAuthorization, WWW-Authenticate, and Proxy-Authenticate header values. 1.18.0 (2021-08-18) Bugs Fixed Fixed a bug where a buffered error responses on .NET Framework were prematurely disposed Fixed relative redirect support. 1.17.0 (2021-08-10) Features Added Added ClientOptions.Default to configure defaults process-wide. Added HttpPipelinePosition.BeforeTransport to be able to add policies at the end of the pipeline before the transport. Fixed Fixed NotSupportedException when running in Unity. 1.16.0 (2021-06-30) Changed Added TenantId to the properties on TokenRequestContext to enable multi-tenant support in Azure.Identity. 1.15.0 (2021-06-08) Features Added Types to represent GeoJson primitives. Changed Response.Content no longer throws InvalidOperationException when the response is backed by a MemoryStream with a non publicly visible buffer. 1.14.0 (2021-05-11) Features Added Added additional methods to BearerTokenAuthenticationPolicy, which enables creation of authentication policies that can handle challenges. 1.13.0 (2021-04-07) Key Bug Fixes Fixed NotSupportedException when running using Blazor in the browser. Disable the response caching and enable the streaming when running using Blazor in the browser. 1.12.0 (2021-04-06) Features Added Added HttpPipeline.CreateHttpMessagePropertiesScope that can be used to inject scoped properties into HttpMessage. 1.11.0 (2021-03-22) Features Added Operation base class for operations that do not return a value. Added Content property to Response which returns the body of the response as a BinaryData if the body is buffered. AzureNamedKeyCredential has been implemented to cover scenarios where services require that a shared key name and the key value be used as a component of the algorithm to form the authorization token. Key Bug Fixes Check the JsonIgnoreAttribute.Condition property added in .NET 5 when discovering members with JsonObjectSerializer. ETag now returns string.Empty if it is constructed with a null value. Keep-Alive connections are recycled every 300 seconds to observe DNS changes. 1.10.0 (2021-03-09) Features Added Added CloudEvent type based on the CloudEvent spec. 1.9.0 (2021-02-09) Features Added Added Serialize overloads on ObjectSerializer that serialize to BinaryData. Added AzureCoreExtensions containing extensions methods for BinaryData that allow deserializing with an ObjectSerializer. Key Bug Fixes Avoid ObjectDisposedException when the request is cancelled during content upload over HTTPS. Fix exception while setting If-Modified-Since header on .NET Framework. 1.8.1 (2021-01-11) Key Bug Fixes Include Microsoft.Bcl.AsyncInterfaces dependency on .NET 5 to avoid build issues in applications targeting .NET 5. 1.8.0 (2021-01-06) Features Added AzureSasCredential and its respective policy. Key Bug Fixes Avoid a causing and ignoring an exception when setting network stream timeout on .NET Core. 1.7.0 (2020-12-14) New Features System.Text.Json.JsonConverter implementation for the ETag Synchronous HttpClient support on .NET 5. Key Bug Fixes System proxy settings are correctly applied on .NET Framework 1.6.0 (2020-10-28) Features Added The HttpClientTransport(HttpMessageHandler) constructor overload. The JsonPatchDocument type. Key Bugs Fixed The race condition in AzureEventSourceListener class that sometimes resulted in a NullReferenceException in the EventSource. The overflow exception when content length is larger than int.MaxValue. 1.5.1 (2020-10-01) Changed ServicePointManager Connection limit is automatically increased to 50 for Azure endpoints. 1.5.0 (2020-09-03) Changed ETag now supports weak ETags and implements an overload for ToString that accepts a format string. Features Added HttpWebRequest-based transport implementation. Enabled by-default on .NET Framework. Can be disabled using AZURE_CORE_DISABLE_HTTPWEBREQUESTTRANSPORT environment variable or Azure.Core.Pipeline.DisableHttpWebRequestTransport AppContext switch. To use the app context switch add the following snippet to your .csproj: <ItemGroup> <RuntimeHostConfigurationOption Include=\"Azure.Core.Pipeline.DisableHttpWebRequestTransport\" Value=\"true\" /> </ItemGroup> When the environment variable or the switch are set the HttpClientTransport would be used by default instead. 1.4.1 (2020-08-18) Key Bugs Fixed Bug in TaskExtensions.EnsureCompleted method that causes it to unconditionally throw an exception in the environments with synchronization context 1.4.0 (2020-08-06) Features Added Added ObjectSerializer base class for serialization. Added IMemberNameConverter for converting member names to serialized property names. Added JsonObjectSerializer that implements ObjectSerializer for System.Text.Json. Key Bugs Fixed Connection leak for retried non-buffered requests on .NET Framework. 1.3.0 (2020-07-02) Features Added HttpPipeline.CreateClientRequestIdScope method to allow setting client request id on outgoing requests. 1.2.2 (2020-06-04) Key Bugs Fixed Retry server timeouts on .NET Framework. 1.2.1 (2020-04-30) Changed Read client request ID value used for logging and tracing off the initial request object if available. Key Bugs Fixed Fixed a bug when using Azure.Core based libraries in Blazor WebAssembly apps. 1.2.0 (2020-04-03) Features Added AzureKeyCredential and its respective policy. Changed Response trace messages are properly identified. Content type \"application/x-www-form-urlencoded\" is decoded in trace messages. 1.1.0 (2020-03-05) Fixes and improvements Add OPTIONS and TRACE HTTP request methods. Add NetworkTimeout property to RetryOptions and apply it to network operations like sending request or reading from the response stream. Implement serialization for RequestFailedException. 1.0.2 (2020-01-10) Block bearer token authentication for non TLS protected endpoints. Add support for retrying on request timeouts. Add support for retrying on 408, 500, 502, 504 status codes. Remove commit hash from User-Agent telemetry. 1.0.1 Fix issues with log redaction where first query character was replaced with '?' character. Exclude EventCounter events from AzureEventSourceListener. Add AZURE_TRACING_DISABLED environment variable support. 1.0.0 Updating versioning and packaging for general availability. Make types and namespace names consistent. 1.0.0-preview.9 Added console and trace logger listener. Added additional content and header logging options. Moved commonly used types to Azure namespace. 1.0.0-preview.8 Minor improvements and bug fixes. 1.0.0-preview.7 Support for distributed tracing added. Support for TokenCredential in ASP.NET Core integration added. Shared types for long running operations and async collections added. .NET Core dependencies updated to preview7. Bug fixes."
  },
  "packages/Azure.Core.1.47.1/README.html": {
    "href": "packages/Azure.Core.1.47.1/README.html",
    "title": "Azure Core shared client library for .NET | mysite",
    "summary": "Azure Core shared client library for .NET Azure.Core provides shared primitives, abstractions, and helpers for modern .NET Azure SDK client libraries. These libraries follow the Azure SDK Design Guidelines for .NET and can be easily identified by package and namespaces names starting with 'Azure', e.g. Azure.Storage.Blobs. A more complete list of client libraries using Azure.Core can be found here. Azure.Core allows client libraries to expose common functionality in a consistent fashion, so that once you learn how to use these APIs in one client library, you will know how to use them in other client libraries. Source code | Package (NuGet) | API reference documentation Getting started Typically, you will not need to install Azure.Core; it will be installed for you when you install one of the client libraries using it. In case you want to install it explicitly (to implement your own client library, for example), you can find the NuGet package here. Key concepts The main shared concepts of Azure.Core (and so Azure SDK libraries using Azure.Core) include: Configuring service clients, e.g. configuring retries, logging (ClientOptions). Accessing HTTP response details (Response, Response<T>). Calling long-running operations (Operation<T>). Paging and asynchronous streams (AsyncPageable<T>). Exceptions for reporting errors from service requests in a consistent fashion. (RequestFailedException). Customizing requests (RequestContext). Abstractions for representing Azure SDK credentials. (TokenCredentials). Below, you will find sections explaining these shared concepts in more detail. Thread safety We guarantee that all client instance methods are thread-safe and independent of each other (guideline). This ensures that the recommendation of reusing client instances is always safe, even across threads. Additional concepts Client options | Accessing the response | Long-running operations | Handling failures | Diagnostics | Mocking | Client lifetime Examples NOTE: Samples in this file apply only to packages that follow Azure SDK Design Guidelines. Names of such packages usually start with Azure. Configuring Service Clients Using ClientOptions Azure SDK client libraries typically expose one or more service client types that are the main starting points for calling corresponding Azure services. You can easily find these client types as their names end with the word Client. For example, BlockBlobClient can be used to call blob storage service, and KeyClient can be used to access Key Vault service cryptographic keys. These client types can be instantiated by calling a simple constructor, or its overload that takes various configuration options. These options are passed as a parameter that extends ClientOptions class exposed by Azure.Core. Various service specific options are usually added to its subclasses, but a set of SDK-wide options are available directly on ClientOptions. SecretClientOptions options = new SecretClientOptions() { Retry = { Delay = TimeSpan.FromSeconds(2), MaxRetries = 10, Mode = RetryMode.Fixed }, Diagnostics = { IsLoggingContentEnabled = true, ApplicationId = \"myApplicationId\" } }; SecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential(), options); More on client configuration in client configuration samples. Accessing HTTP Response Details Using Response<T> Service clients have methods that can be used to call Azure services. We refer to these client methods service methods. Service methods return a shared Azure.Core type Response<T> (in rare cases its non-generic sibling, a raw Response). This type provides access to both the deserialized result of the service call, and to the details of the HTTP response returned from the server. // create a client var client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential()); // call a service method, which returns Response<T> Response<KeyVaultSecret> response = await client.GetSecretAsync(\"SecretName\"); // Response<T> has two main accessors. // Value property for accessing the deserialized result of the call KeyVaultSecret secret = response.Value; // .. and GetRawResponse method for accessing all the details of the HTTP response Response http = response.GetRawResponse(); // for example, you can access HTTP status int status = http.Status; // or the headers foreach (HttpHeader header in http.Headers) { Console.WriteLine($\"{header.Name} {header.Value}\"); } More on response types in response samples. Setting up console logging To create an Azure SDK log listener that outputs messages to console use AzureEventSourceListener.CreateConsoleLogger method. // Setup a listener to monitor logged events. using AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger(); More on logging in diagnostics samples. Reporting Errors RequestFailedException When a service call fails Azure.RequestFailedException would get thrown. The exception type provides a Status property with an HTTP status code and an ErrorCode property with a service-specific error code. try { KeyVaultSecret secret = client.GetSecret(\"NonexistentSecret\"); } // handle exception with status code 404 catch (RequestFailedException e) when (e.Status == 404) { // handle not found error Console.WriteLine(\"ErrorCode \" + e.ErrorCode); } More on handling responses in response samples. Consuming Service Methods Returning AsyncPageable<T> If a service call returns multiple values in pages, it would return Pageable<T>/AsyncPageable<T> as a result. You can iterate over AsyncPageable directly or in pages. // call a service method, which returns AsyncPageable<T> AsyncPageable<SecretProperties> allSecretProperties = client.GetPropertiesOfSecretsAsync(); await foreach (SecretProperties secretProperties in allSecretProperties) { Console.WriteLine(secretProperties.Name); } For more information on paged responses, see Pagination with the Azure SDK for .NET. Consuming Long-Running Operations Using Operation<T> Some operations take long time to complete and require polling for their status. Methods starting long-running operations return *Operation<T> types. The WaitForCompletionAsync method is an easy way to wait for operation completion and get the resulting value. // create a client SecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential()); // Start the operation DeleteSecretOperation operation = await client.StartDeleteSecretAsync(\"SecretName\"); Response<DeletedSecret> response = await operation.WaitForCompletionAsync(); DeletedSecret value = response.Value; Console.WriteLine(value.Name); Console.WriteLine(value.ScheduledPurgeDate); More on long-running operations in long-running operation samples. Customizing Requests Using RequestContext Besides general configuration of service clients through ClientOptions, it is possible to customize the requests sent by service clients using protocol methods or convenience APIs that expose RequestContext as a parameter. var context = new RequestContext(); context.AddClassifier(404, isError: false); Response response = await client.GetPetAsync(\"pet1\", context); More on request customization in RequestContext samples. Mocking One of the most important cross-cutting features of our new client libraries using Azure.Core is that they are designed for mocking. Mocking is enabled by: providing a protected parameterless constructor on client types. making service methods virtual. providing APIs for constructing model types returned from virtual service methods. To find these factory methods look for types with the ModelFactory suffix, e.g. SecretModelFactory. For example, the ConfigurationClient.Get method can be mocked (with Moq) as follows: // Create a mock response var mockResponse = new Mock<Response>(); // Create a mock value var mockValue = SecretModelFactory.KeyVaultSecret( SecretModelFactory.SecretProperties(new Uri(\"http://example.com\")) ); // Create a client mock var mock = new Mock<SecretClient>(); // Setup client method mock.Setup(c => c.GetSecret(\"Name\", null, default)) .Returns(Response.FromValue(mockValue, mockResponse.Object)); // Use the client mock SecretClient client = mock.Object; KeyVaultSecret secret = client.GetSecret(\"Name\"); More on mocking in Unit testing and mocking with the Azure SDK for .NET. Distributed tracing with OpenTelemetry Azure SDKs are instrumented for distributed tracing using OpenTelemetry. Distributed tracing allows to follow request through multiple services, record how long network or logical call take along with structured properties describing such operations. More on diagnostics in diagnostics samples. To setup distributed tracing for your application follow your observability vendor documentation. If you use Azure Monitor, follow the Start Monitoring Application guide. Troubleshooting Three main ways of troubleshooting failures are inspecting exceptions, enabling logging, and distributed tracing Next steps Explore and install available Azure SDK libraries. Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com. When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repositories using our CLA. This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments."
  },
  "packages/Azure.Identity.1.14.2/CHANGELOG.html": {
    "href": "packages/Azure.Identity.1.14.2/CHANGELOG.html",
    "title": "Release History | mysite",
    "summary": "Release History 1.15.0-beta.1 Features Added Expanded the set of acceptable values for environment variable AZURE_TOKEN_CREDENTIALS to allow for selection of a specific credential in the DefaultAzureCredential chain. The valid values now include any of the credential names available in the default chain (VisualStudioCredential, VisualStudioCodeCredential, AzureCliCredential, AzurePowerShellCredential, AzureDeveloperCliCredential, EnvironmentCredential, WorkloadIdentityCredential, ManagedIdentityCredential, InteractiveBrowserCredential, or BrokerAuthenticationCredential.) Note: BrokerAuthenticationCredential requires that the project include a reference to package Azure.Identity.Broker. Breaking Changes Bugs Fixed ManagedIdentityCredential now retries 410 status responses for at least 70 seconds total duration as required by Azure IMDS documentation. Previously, 410 responses were retried with the same short exponential backoff as other status codes, resulting in insufficient retry duration (#50724). ManagedIdentityCredential throws CredentialUnavailableException when the IMDS endpoint is unavailable. This addresses a regression in how it behaves in the ChainedTokenCredential (47057). Other Changes VisualStudioCredential throws CredentialUnavailableException for all failures except for OperationCancelledException due to cancellation being requested for a CancellationToken. This ensures that it falls through for most failures when part of a chained credential. Removed AzureApplicationCredential. For context, see issue 49781. 1.14.2 (2025-07-10) Other changes Updated Microsoft.Identity.Client dependency to version 4.73.1 1.14.1 (2025-06-24) Bugs Fixed Added support in AzurePowerShellCredential for the Az.Accounts 5.0.0+ (Az 14.0.0+) breaking change where Get-AzAccessToken returns PSSecureAccessToken with a SecureString Token property instead of plaintext. 1.14.0 (2025-05-13) Other Changes Removed references to Username, Password, AZURE_USERNAME, and AZURE_PASSWORD in XML comments from EnvironmentCredentialOptions and EnvironmentCredential due to lack of MFA support. See MFA enforcement details. Marked AZURE_USERNAME and AZURE_PASSWORD as obsolete due to lack of MFA support. See MFA enforcement details. Added support for the AZURE_TOKEN_CREDENTIALS environment variable to DefaultAzureCredential, which allows for choosing between 'deployed service' and 'developer tools' credentials. Valid values are 'dev' for developer tools and 'prod' for deployed service. 1.14.0-beta.4 (2025-05-01) Bugs Fixed Fixed an issue where Azure CLI credential could hang or delay due to I/O contention when standard input/output was shared with the host process (#49582). Other Changes Updated Microsoft.Identity.Client dependency to version 4.71.1 1.14.0-beta.3 (2025-04-08) Features Added DefaultAzureCredential now includes silent authentication via the authentication broker on Windows if the Azure.Identity.Broker NuGet package is referenced. This allows for a more seamless authentication experience when using the DefaultAzureCredential in Windows environments. Setting the ExcludeBrokerCredential property on DefaultAzureCredentialOptions disables this feature. Bugs Fixed DefaultAzureCredential no longer sends a probe request on each call to GetToken. It now only happens on the first call. Other Changes Marked VisualStudioCodeCredential as obsolete because the VS Code Azure Account extension on which this credential relies has been deprecated. See the Azure Account extension deprecation notice here. 1.14.0-beta.2 (2025-03-11) Bugs Fixed VisualStudioCredential will now correctly fall through to the next credential in the chain when no account is found by Visual Studio. (#48464) Other Changes Updated Microsoft.Identity.Client dependency to version 4.69.1. ManagedIdentityCredential now properly supports CAE. An event is now logged when the ManagedIdentityCredential is used directly or indirectly via a credential chain indicating which managed identity source was selected and which ManagedIdentityId was specified. Marked UsernamePasswordCredential as obsolete because Resource Owner Password Credentials (ROPC) token grant flow is incompatible with multifactor authentication (MFA), which Microsoft Entra ID requires for all tenants. See https://aka.ms/azsdk/identity/mfa for details about MFA enforcement and migration guidance. 1.14.0-beta.1 (2025-02-11) Features Added Added a Subscription property to AzureCliCredentialOptions to allow specifying the Azure subscription ID or name to use when authenticating with the Azure CLI. Bugs Fixed Null or empty responses from IMDS probe attempts will now fall through to the next credential in the chain (#47844) Other Changes AzurePowerShellCredential no longer relies on APIs that are not available in Constrained Language Mode. 1.13.2 (2025-01-14) Bugs Fixed Fixed an issue where setting DefaultAzureCredentialOptions.TenantId twice throws an InvalidOperationException (#47035) Fixed an issue where ManagedIdentityCredential does not honor the CancellationToken passed to GetToken and GetTokenAsync. (#47156) Fixed an issue where some credentials in DefaultAzureCredential would not fall through to the next credential in the chain under certain exception conditions. Fixed a regression in ManagedIdentityCredential when used in a ChainedTokenCredential where the invalid json responses do not fall through to the next credential in the chain. (#47470) 1.13.1 (2024-10-24) Bugs Fixed Fixed a regression that prevented ManagedIdentityCredential from attempting to detect if Workload Identity is enabled in the current environment. #46653 Fixed a regression that prevented DefaultAzureCredential from progressing past ManagedIdentityCredential in some scenarios where the identity was not available. #46709 1.13.0 (2024-10-14) Breaking Changes Previously, if a clientID or ResourceID was specified for Cloud Shell managed identity, which is not supported, the clientID or resourceID would be silently ignored. Now, an exception will be thrown if a clientID or resourceID is specified for Cloud Shell managed identity. Previously, if a clientID or ResourceID was specified for Service Fabric managed identity, which is not supported, the clientID or resourceID would be silently ignored. Now, an exception will be thrown if a clientID or resourceID is specified for Service Fabric managed identity. Features Added ManagedIdentityCredential now supports specifying a user-assigned managed identity by object ID. Bugs Fixed If DefaultAzureCredential attempts to authenticate with the MangagedIdentityCredential and it receives either a failed response that is not json, it will now fall through to the next credential in the chain. #45184 Fixed the request sent in AzurePipelinesCredential so it doesn't result in a redirect response when an invalid system access token is provided. Updated to version 4.65.0 of Microsoft.Identity.Client to address a bug preventing the use of alternate authority types such as dStS (4927) . Other Changes The logging level passed to MSAL now correlates to the log level configured on your configured AzureEventSourceListener. Previously, the log level was always set to Microsoft.Identity.Client.LogLevel.Info. AzurePowerShellCredential now utilizes the AsSecureString parameter to Get-AzAccessToken for version 2.17.0 and greater of the Az.Accounts module. Improved error logging for AzurePipelinesCredential. 1.13.0-beta.2 (2024-09-17) Features Added ManagedIdentityCredential now supports specifying a user-assigned managed identity by object ID. Bugs Fixed If DefaultAzureCredential attempts to authenticate with the MangagedIdentityCredential and it receives either a failed response that is not json, it will now fall through to the next credential in the chain. #45184 Other Changes AzurePowerShellCredential now utilizes the AsSecureString parameter to Get-AzAccessToken for version 2.17.0 and greater of the Az.Accounts module. 1.13.0-beta.1 (2024-07-24) Breaking Changes Previously, if a clientID or ResourceID was specified for Cloud Shell managed identity, which is not supported, the clientID or resourceID would be silently ignored. Now, an exception will be thrown if a clientID or resourceID is specified for Cloud Shell managed identity. Other Changes The logging level passed to MSAL now correlates to the log level configured on your configured AzureEventSourceListener. Previously, the log level was always set to Microsoft.Identity.Client.LogLevel.Info. 1.12.0 (2024-06-17) Features Added Added AzurePipelinesCredential for authenticating with Azure Pipelines service connections. OnBehalfOfCredential now supports client assertion callbacks for acquiring tokens on behalf of a user. All credentials now support setting RefreshOn value if received from MSAL. ManagedIdentityCredential sets RefreshOn value of half the token lifetime for AccessTokens with an ExpiresOn value greater than 2 hours in the future. ClientAssertionCredentialOptions now supports TokenCachePersistenceOptions for configuring token cache persistence. 1.12.0-beta.3 (2024-06-11) Features Added OnBehalfOfCredential now supports client assertion callbacks for acquiring tokens on behalf of a user. All credentials now support setting RefreshOn value if received from MSAL. ManagedIdentityCredential sets RefreshOn value of half the token lifetime for AccessTokens with an ExpiresOn value greater than 2 hours in the future. Breaking Changes The constructor of AzurePipelinesCredential now includes additional required parameters for the Azure Pipelines service connection. Bugs Fixed Bug fixes for AzurePipelinesCredential Managed identity bug fixes. 1.11.4 (2024-06-10) Bugs Fixed Managed identity bug fixes. 1.12.0-beta.2 (2024-05-07) Features Added ClientAssertionCredentialOptions now supports TokenCachePersistenceOptions for configuring token cache persistence. Added AzurePipelinesCredential for authenticating with Azure Pipelines service connections. Bugs Fixed Fixed a regression in DefaultAzureCredential probe request behavior for IMDS managed identity environments. #43796 1.11.3 (2024-05-07) Bugs Fixed Fixed a regression in DefaultAzureCredential probe request behavior for IMDS managed identity environments. #43796 1.12.0-beta.1 (2024-04-23) Bugs Fixed An experimental overload Authenticate method on InteractiveBrowserCredential now supports the experimental PopTokenRequestContext parameter. 1.11.2 (2024-04-19) Bugs Fixed Fixed an issue which caused claims to be incorrectly added to confidential client credentials such as DeviceCodeCredential #43468 1.11.1 (2024-04-16) Other Changes Updated Microsoft.Identity.Client and related dependencies to version 4.60.3 1.11.0 (2024-04-09) Bugs Fixed AzurePowerShellCredential now handles the case where it falls back to legacy PowerShell without relying on the error message string. Breaking Changes DefaultAzureCredential now sends a probe request with no retries for IMDS managed identity environments to avoid excessive retry delays when the IMDS endpoint is not available. This should improve credential chain resolution for local development scenarios. See BREAKING_CHANGES.md. 1.11.0-beta.1 (2024-02-06) Bugs Fixed Claims from the TokenRequestContext are now correctly sent through to MSAL in ConfidentialClient credentials. #40451. ManagedIdentityCredential is more lenient with the error message it matches when falling through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint. #38218 Other Changes AzureCliCredential utilizes the new expires_on property returned by az account get-access-token to determine token expiration. 1.10.4 (2023-11-13) Breaking Changes One of Azure.Identity's dependencies, Microsoft.Identity.Client, inadvertently added a dependency to WindowsForms when targeting netX.0-windows instead of netX.0 in version 4.56.0. An additional installation of .NET Desktop Runtime may be necessary. Manually adding a reference to the latest Microsoft.Identity.Client will remove the need for the .NET Desktop Runtime. #44232 Other Changes Distributed tracing with ActivitySource is stable and no longer requires the Experimental feature-flag. 1.10.3 (2023-10-18) Bugs Fixed ManagedIdentityCredential will now correctly retry when the instance metadata endpoint returns a 410 response. #28568 Other Changes Updated Microsoft.Identity.Client dependency to version 4.56.0 1.10.2 (2023-10-10) Bugs Fixed Bug fixes for development time credentials. 1.10.1 (2023-09-12) Bugs Fixed ManagedIdentityCredential will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint. #38218 Fixed an issue where interactive credentials would still prompt on the first GetToken request even when the cache is populated and an AuthenticationRecord is provided. #38431 1.10.0 (2023-08-14) Features Added Added BrowserCustomization property to InteractiveBrowserCredential to enable web view customization for interactive authentication. Bugs Fixed ManagedIdentityCredential will no longer attempt to parse invalid json payloads on responses from the managed identity endpoint. Fixed an issue where AzurePowerShellCredential fails to parse the token response from Azure PowerShell. #22638 1.10.0-beta.1 (2023-07-17) Features Added Continuous Access Evaluation (CAE) is now configurable per-request by setting the IsCaeEnabled property of TokenRequestContext via its constructor. Added IsUnsafeSupportLoggingEnabled property to TokenCredentialOptions which equates to passing 'true' for the enablePiiLogging parameter to the 'WithLogging' method on the MSAL client builder. Bugs Fixed Fixed an issue with TokenCachePersistenceOptions where credentials in the same process would share the same cache, even if they had different configured names. ManagedIdentityCredential now ignores empty ClientId values. #37100 ManagedIdentityCredential will no longer attempt to parse invalid json payloads on responses from the managed identity endpoint. When utilizing EnvironmentCredential from DefaultAzureCredential the credential will now override the TENANT_ID environment value if the TenantId value is set in DefaultAzureCredentialOptions. Other Changes All developer credentials in the DefaultAzureCredential credential chain will fall through to the next credential in the chain on any failure. Previously, some exceptions would throw AuthenticationFailedException, which stops further progress in the chain. 1.9.0 (2023-05-09) Breaking Changes Changed visibility of all environment variable based properties on EnvironmentCredentialOptions to internal. These options are again only configurable via environment variables. 1.9.0-beta.3 (2023-04-12) Breaking Changes Renamed the developer credential options timeout settings as follows: AzureCliCredential to AzureCliCredentialOptions.ProcessTimeout AzurePowerShellCredential to AzurePowerShellCredentialOptions.ProcessTimeout VisualStudioCredential to VisualStudioCredentialOptions.ProcessTimeout AzureDeveloperCliCredential to AzureDeveloperCliCredentialOptions.ProcessTimeout Bugs Fixed Setting DefaultAzureCredentialOptions.ExcludeWorkloadIdentityCredential to true also excludes TokenExchangeManagedIdentitySource when using DefaultAzureCredential selects the ManagedIdentityCredential 1.9.0-beta.2 (2023-02-21) Features Added Allow VisualStudioCredential on non-Windows platforms Added AzureDeveloperCliCredential for Azure Developer CLI Added WorkloadIdentityCredential to support Azure Workload Identity authentication Added WorkloadIdentityCredential and AzureDeveloperCliCredential to the DefaultAzureCredential authentication flow. Bugs Fixed Fixed ManagedIdentityCredential authentication in sovereign clouds for services specifying TenantId through authentication challenge #34077 Breaking Changes Previously, if environment variables for username and password auth are set in addition to the AZURE_CLIENT_CERTIFICATE_PATH, EnvironmentCredential would select the UsernamePasswordCredential. After this change, ClientCertificateCredential will be selected, which is consistent with all other languages. This is potentially a behavioral breaking change. 1.8.2 (2023-02-08) Bugs Fixed Fixed error message parsing in AzurePowerShellCredential which would misinterpret Microsoft Entra ID errors with the need to install PowerShell. #31998 Fix regional endpoint validation error when using ManagedIdentityCredential. [#32498])(https://github.com/Azure/azure-sdk-for-net/issues/32498) 1.8.1 (2023-01-13) Bugs Fixed Fixed an issue when using ManagedIdentityCredential in combination with authorities other than Azure public cloud that resulted in a incorrect instance metadata validation error. #32498 1.8.0 (2022-11-08) Bugs Fixed Fixed error message parsing in AzureCliCredential which would misinterpret Microsoft Entra ID errors with the need to login with az login. #26894, #29109 ManagedIdentityCredential will no longer fail when a response received from the endpoint is invalid JSON. It now treats this scenario as if the credential is unavailable. #30467, #32061 1.9.0-beta.1 (2022-10-13) Features Added Credentials that are implemented via launching a sub-process to acquire tokens now have configurable timeouts. This addresses scenarios where these proceses can take longer than the current default timeout values. (A community contribution, courtesy of reynaldoburgos). The affected credentials and their associated options are: AzureCliCredential and AzureCliCredentialOptions.CliProcessTimeout AzurePowerShellCredential and AzurePowerShellCredentialOptions.PowerShellProcessTimeout VisualStudioCredential and VisualStudioCredentialOptions.VisualStudioProcessTimeout DefaultAzureCredential and DefaultAzureCredentialOptions.DeveloperCredentialTimeout Note: this option applies to all developer credentials above when using DefaultAzureCredential. Acknowledgments Thank you to our developer community members who helped to make Azure Identity better with their contributions to this release: reynaldoburgos 1.8.0-beta.1 (2022-10-13) Features Added Reintroduced ManagedIdentityCredential token caching support from 1.7.0-beta.1 EnvironmentCredential updated to support specifying a certificate password via the AZURE_CLIENT_CERTIFICATE_PASSWORD environment variable Breaking Changes Excluded VisualStudioCodeCredential from DefaultAzureCredential token chain by default as SDK authentication via Visual Studio Code is broken due to issue #27263. The VisualStudioCodeCredential will be re-enabled in the DefaultAzureCredential flow once a fix is in place. Issue #30525 tracks this. In the meantime Visual Studio Code users can authenticate their development environment using the Azure CLI. 1.7.0 (2022-09-19) Features Added Added AdditionallyAllowedTenants to the following credential options to force explicit opt-in behavior for multi-tenant authentication: AuthorizationCodeCredentialOptions AzureCliCredentialOptions AzurePowerShellCredentialOptions ClientAssertionCredentialOptions ClientCertificateCredentialOptions ClientSecretCredentialOptions DefaultAzureCredentialOptions OnBehalfOfCredentialOptions UsernamePasswordCredentialOptions VisualStudioCodeCredentialOptions VisualStudioCredentialOptions Added TenantId to DefaultAzureCredentialOptions to avoid having to set InteractiveBrowserTenantId, SharedTokenCacheTenantId, VisualStudioCodeTenantId, and VisualStudioTenantId individually. Bugs Fixed Fixed overly restrictive scope validation to allow the '_' character, for common scopes such as user_impersonation #30647 Breaking Changes Credential types supporting multi-tenant authentication will now throw AuthenticationFailedException if the requested tenant ID doesn't match the credential's tenant ID, and is not included in the AdditionallyAllowedTenants option. Applications must now explicitly add additional tenants to the AdditionallyAllowedTenants list, or add '*' to list, to enable acquiring tokens from tenants other than the originally specified tenant ID. See BREAKING_CHANGES.md. ManagedIdentityCredential token caching added in 1.7.0-beta.1 has been removed from this release and will be added back in 1.8.0-beta.1 1.7.0-beta.1 (2022-08-09) Features Added ManagedIdentityCredential will now internally cache tokens. Apps can call GetToken or GetTokenAsync directly without needing to cache to avoid throttling. 1.6.1 (2022-08-08) Bugs Fixed Fixed AZURE_REGIONAL_AUTHORITY_NAME support in ClientCertificateCredential #29112 Fixed regression in SharedTokenCacheCredential default behavior #28029 Fixed legacy PowerShell discovery failures #28030 (A community contribution, courtesy of nerddtvg) Other Changes Documentation improvements to TokenCacheRefreshArgs and EnvironmentCredential (Community contributions, courtesy of pmaytak and goenning) Acknowledgments Thank you to our developer community members who helped to make Azure Identity better with their contributions to this release: nerddtvg pmaytak goenning 1.6.0 (2022-04-05) Features Added Added a new property under the Diagnostics options available on TokenCredentialOptions and all sub-types. If set to true, we try to log the account identifiers by parsing the received access token. The account identifiers we try to log are the: Application or Client Identifier User Principal Name Tenant Identifier Object Identifier of the authenticated user or app ManagedIdentityCredential now attempts to use the newest \"2019-08-01\" api version for App Service Managed Identity sources. The newer API version will be used if the IDENTITY_ENDPOINT and IDENTITY_HEADER environment variables are set. Bugs Fixed Fixed an issue where the x5c header is not sent for OnBehalfOfCredential when the SendCertificateChain option is set. #27679 1.6.0-beta.1 (2022-02-11) Features Added EnvironmentCredential now supports certificate subject name / issuer based authentication with AZURE_CLIENT_SEND_CERTIFICATE_CHAIN environment variable (A community contribution, courtesy of trevorlacey-msft). ManagedIdentityCredential now supports accepting a ResourceIdentifier argument to specify a User Assigned Managed Identity by resource Id rather than client Id. DefaultAzureCredential also supports this via the ManagedIdentityResourceId property of DefaultAzureCredentialOptions. Added ClientAssertionCredential for authenticating service principals with a presigned client assertion. Bugs Fixed Fixed AuthenticationFailedException from AzurePowerSheellCredential when not logged in on non-windows platforms #23498 Fixed ManagedIdentityCredential response parsing to handle non-json responses #24158 Other Changes Upgraded MSAL dependency to version 4.39.0 Acknowledgments Thank you to our developer community members who helped to make Azure Identity better with their contributions to this release: Trevor Lacey (GitHub) 1.5.0 (2021-10-14) Breaking Changes from 1.5.0-beta.4 The AllowMultiTenantAuthentication option has been removed and the default behavior is now as if it were true. The multi-tenant discovery feature can be totally disabled by either setting an AppContext switch named \"Azure.Identity.DisableTenantDiscovery\" to true or by setting the environment variable \"AZURE_IDENTITY_DISABLE_MULTITENANTAUTH\" to \"true\". Removed the IsPIILoggingEnabled property from TokenCredentialOptions, similar functionality is planned to be added to TokenCredentialOptions.Diagnostics in a later release. Removed RegionalAuthority from ClientCertificateCredentialOptions and ClientSecretCredentialOptions, along with the RegionalAuthority type. Renamed struct TokenCacheDetails to TokenCacheData. Renamed class TokenCacheNotificationDetails to TokenCacheRefreshArgs. Updated CacheBytes property on TokenCacheData to be readonly and a required constructor parameter. Bugs Fixed Fixed issue with AuthorizationCodeCredential not specifying correct redirectUrl (Issue #24183) Other Changes Updated error messages to include links to the Azure.Identity troubleshooting guide. 1.5.0-beta.4 (2021-09-08) Features Added DefaultAzureCredentialOptions now has a InteractiveBrowserClientId property which allows passing a ClientId value to the InteractiveBrowserCredential when constructing a DefaultAzureCredential. Implement OnBehalfOfCredential which enables authentication to Microsoft Entra ID using an On-Behalf-Of flow. Added support to ManagedIdentityCredential for Azure hosts using federated token exchange for managed identity. Bugs Fixed Refactored IMDS discovery to remove socket probing and caching of failures to improve ManagedIdentityCredential resiliency. #23028 Updated UsernamePasswordCredential to use cached tokens when available #23324 Other Changes Updated credentials using MsalConfidentialClient to include MSAL log output in logs Added additional logging to AzureCliCredential, AzurePowerShellCredential, VisualStudioCredential, and VisualStudioCodeCredential when IsPIILoggingEnabled is set to true. 1.5.0-beta.3 (2021-08-10) Acknowledgments Thank you to our developer community members who helped to make Azure Identity better with their contributions to this release: Tomas Pajurek (tpajurek-dtml) Features Added A new trace event is now logged when DefaultAzureCredential selects a credential during initialization. Added AzureApplicationCredential Added IsPIILoggingEnabled property to TokenCredentialOptions, which controls whether MSAL PII logging is enabled, and other sensitive credential related logging content. Breaking Changes Renamed AZURE_POD_IDENTITY_TOKEN_URL to AZURE_POD_IDENTITY_AUTHORITY_HOST. The value should now be a host, for example \"http://169.254.169.254\" (the default). Bugs Fixed Stopped loading $PROFILE and checking for updates when using AzurePowerShellCredential. Fixed unrecognized argument issue in AzureCliCredential when specifying the TenantId option. #23158 (A community contribution, courtesy of tomas-pajurek). Handled an additional error scenario for AzureCliCredential that prompts developers to run az login when needed. #21758 Fixed an issue in EnvironmentCredential where the supplied options were not getting properly applied. #22787 Fixed DateTime parsing to use the current culture in AzurePowerShellCredential. #22638 1.4.1 (2021-08-04) Fixes and improvements Fixed issue resulting in duplicate event source names when executing in Azure Functions 1.5.0-beta.2 (2021-07-12) New Features Added regional STS support to client credential types Added RegionalAuthority extensible enum Added RegionalAuthority property to ClientSecretCredentialOptions and ClientCertificateCredentialOptions Added support to ManagedIdentityCredential for Bridge to Kubernetes local development authentication. TenantId values returned from service challenge responses can now be used to request tokens from the correct tenantId. To support this feature, there is a new AllowMultiTenantAuthentication option on TokenCredentialOptions. By default, AllowMultiTenantAuthentication is false. When this option property is false and the tenant Id configured in the credential options differs from the tenant Id set in the TokenRequestContext sent to a credential, an AuthorizationFailedException will be thrown. This is potentially breaking change as it could be a different exception than what was thrown previously. This exception behavior can be overridden by either setting an AppContext switch named \"Azure.Identity.EnableLegacyTenantSelection\" to true or by setting the environment variable \"AZURE_IDENTITY_ENABLE_LEGACY_TENANT_SELECTION\" to \"true\". Note: AppContext switches can also be configured via configuration like below: Added OnBehalfOfFlowCredential which enables support for Microsoft Entra On-Behalf-Of (OBO) flow. See the Microsoft Entra ID documentation to learn more about OBO flow scenarios. <ItemGroup> <RuntimeHostConfigurationOption Include=\"Azure.Identity.EnableLegacyTenantSelection\" Value=\"true\" /> </ItemGroup> 1.5.0-beta.1 (2021-06-08) Fixes and improvements Added LoginHint property to InteractiveBrowserCredentialOptions which allows a user name to be pre-selected for interactive logins. Setting this option skips the account selection prompt and immediately attempts to login with the specified account. Added AuthorizationCodeCredentialOptions which allows for configuration of a ReplyUri. 1.4.0 (2021-05-12) New Features By default, the MSAL Public Client Client Capabilities are populated with \"CP1\" to enable support for Continuous Access Evaluation (CAE). This indicates to Microsoft Entra ID that your application is CAE ready and can handle the CAE claim challenge. This capability can be disabled, if necessary, by either setting an AppContext switch named \"Azure.Identity.DisableCP1\" to true or by setting the environment variable; \"AZURE_IDENTITY_DISABLE_CP1\" to \"true\". Note: AppContext switches can also be configured via configuration like below: <ItemGroup> <RuntimeHostConfigurationOption Include=\"Azure.Identity.DisableCP1\" Value=\"true\" /> </ItemGroup> Fixes and improvements The Microsoft Authentication Library (MSAL) dependency versions have been updated to the latest Microsoft.Identity.Client version 4.30.1, Microsoft.Identity.Client.Extensions.Msal version 2.18.4. 1.4.0-beta.5 (2021-04-06) Acknowledgments Thank you to our developer community members who helped to make Azure Identity better with their contributions to this release: Marco Mansi (GitHub) New Features Added AzurePowerShellCredential to DefaultAzureCredential (A community contribution, courtesy of olandese) Fixes and improvements When logging is enabled, the log output from Microsoft Authentication Library (MSAL) is also logged. Fixed an issue where an account credential fails to load from the cache when EnableGuestTenantAuthentication is true and the account found in the cache has multiple matching tenantIds (#18276). Fixed deadlock issue in InteractiveBrowserCredential when running in a UI application (#18418). Breaking Changes TokenCache class is moved removed from the public API surface and has been replaced by TokenCachePersistenceOptions for configuration of disk based persistence of the token cache. 1.4.0-beta.4 (2021-03-09) Fixes and Improvements Added the [Serializable] attribute to all custom exception types. Breaking Changes Update the default value of ExcludeSharedTokenCacheCredential on DefaultAzureCredentialsOptions to true, to exclude the SharedTokenCacheCredential from the DefaultAzureCredential by default. See BREAKING_CHANGES.md 1.4.0-beta.3 (2021-02-09) Breaking Changes The IDisposable interface has been removed from TokenCache. New Features All credentials added support to handle the Claims property on TokenRequestContext 1.4.0-beta.2 (2021-01-29) Fixes and improvements Fixed issue in HttpExtensions causing the omission of content headers on requests (#17448) Made EnvironmentCredential to account for both null and empty string when checking for the presense of the environment variables (#18031) 1.3.0 (2020-11-12) New Features Added support for Service Fabric managed identity authentication to ManagedIdentityCredential. Added support for Azure Arc managed identity authentication to ManagedIdentityCredential. Fixes and improvements Fix race condition in ProcessRunner causing VisualStudioCredential and AzureCliCredential to fail intermittently (#16211) Fix VisualStudioCodeCredential to raise CredentialUnavailableException when reading from VS Code's stored secret (#16795) Prevent VisualStudioCodeCredential using invalid authentication data when no user is signed in to Visual Studio Code (#15870) Fix deadlock in ProcessRunner causing AzureCliCredential and VisualStudioCredential to fail due to timeout (#14691, 14207) Fix issue with AzureCliCredential incorrectly parsing expires on property returned from az account get-access-token (#15801) Fix issue causing DeviceCodeCredential and InteractiveBrowserCredential to improperly authenticate to the home tenant for silent authentication calls after initial authentication (#13801) Fix cache loading issue in SharedTokenCacheCredential on Linux (#12939) Breaking Changes Rename property IncludeX5CCliamHeader on ClientCertificateCredentialOptions to SendCertificateChain Removing Application Authentication APIs for GA release. These will be reintroduced in 1.4.0-beta.1. Removed class AuthenticationRecord Removed class AuthenticationRequiredException Removed class ClientSecretCredentialOptions and ClientSecretCredential constructor overloads accepting this type Removed class UsernamePasswordCredentialOptions and UsernamePasswordCredential constructor overloads accepting this type Removed properties EnablePersistentCache and AllowUnprotectedCache from ClientCertificateCredentialOptions, DeviceCodeCredentialOptions and InteractiveBrowserCredentialOptions Removed properties AuthenticationRecord and DisableAutomaticAuthentication from DeviceCodeCredentialOptions and InteractiveBrowserCredentialOptions Removed properties AllowUnencryptedCacheand AuthenticationRecord from SharedTokenCacheCredentialOptions Removed methods Authenticate and AuthenticateAsync from DeviceCodeCredential, InteractiveBrowserCredential and UsernamePasswordCredential 1.4.0-beta.1 (2020-10-15) New Features Redesigned Application Authentication APIs Adds TokenCache and TokenCache classes to give more user control over how the tokens are cached and how the cache is persisted. Adds TokenCache property to options for credentials supporting token cache configuration. 1.3.0-beta.2 (2020-10-07) New Features Update DeviceCodeCredential to output device code information and authentication instructions in the console, in the case no deviceCodeCallback is specified. Added DeviceCodeCallback to DeviceCodeCredentialOptions Added default constructor to DeviceCodeCredential Breaking Changes Replaced DeviceCodeCredential constructor overload taking deviceCodeCallback and DeviceCodeCredentialOptions with constructor taking only DeviceCodeCredentialOptions 1.3.0-beta.1 (2020-09-11) New Features Restoring Application Authentication APIs from 1.2.0-preview.6 Added support for App Service Managed Identity API version 2019-08-01 (#13687) Added IncludeX5CClaimHeader to ClientCertificateCredentialOptions to enable subject name / issuer authentication with the ClientCertificateCredential. Added RedirectUri to InteractiveBrowserCredentialOptions to enable authentication with user specified application with a custom redirect url. Added IdentityModelFactory to enable constructing models from the Azure.Identity library for mocking. Unify exception handling between DefaultAzureCredential and ChainedTokenCredential (#14408) Fixes and improvements Updated MsalPublicClient and MsalConfidentialClient to respect CancellationToken during initialization (#13201) Fixed VisualStudioCodeCredential crashes on macOS (Issue #14362) Fixed issue with non GUID Client Ids (Issue #14585) Update VisualStudioCredential and VisualStudioCodeCredential to throw CredentialUnavailableException for ADFS tenant (Issue #14639) 1.2.3 (2020-09-11) Fixes and improvements Fixed issue with DefaultAzureCredential incorrectly catching AuthenticationFailedException (Issue #14974) Fixed issue with DefaultAzureCredential throwing exceptions during concurrent calls (Issue #15013) 1.2.2 (2020-08-20) Fixes and improvements Fixed issue with InteractiveBrowserCredential not specifying correct redirectUrl (Issue #13940) 1.2.1 (2020-08-18) Fixes and improvements Bug in TaskExtensions.EnsureCompleted method that causes it to unconditionally throw an exception in the environments with synchronization context 1.2.0 (2020-08-10) Breaking Changes Removing Application Authentication APIs for GA release. These will be reintroduced in 1.3.0-preview. Removed class AuthenticationRecord Removed class AuthenticationRequiredException Removed class ClientCertificateCredentialOptions and ClientCertificateCredential constructor overloads accepting this type Removed class ClientSecretCredentialOptions and ClientSecretCredential constructor overloads accepting this type Removed class DeviceCodeCredentialOptions and DeviceCodeCredential constructor overloads accepting this type Removed class InteractiveBrowserCredentialOptions and InteractiveBrowserCredential constructor overloads accepting this type Removed class UsernamePasswordCredentialOptions and UsernamePasswordCredential constructor overloads accepting this type Removed methods Authenticate and AuthenticateAsync from DeviceCodeCredential Removed methods Authenticate and AuthenticateAsync from InteractiveBrowserCredential Removed methods Authenticate and AuthenticateAsync from UsernamePasswordCredential Removed properties AllowUnencryptedCacheand AuthenticationRecord from SharedTokenCacheCredentialOptions Fixes and improvements Fixed excess errors in DefaultAzureCredential tracing (Issue #10659) Fixed concurrency issue in DefaultAzureCredential (Issue #13044) 1.2.0-preview.6 (2020-07-22) New Features Added the read only property ClientId to AuthenticationRecord. Added the property AllowUnencryptedCache to the option classes ClientCertificateCredentialOptions, ClientSecretCredentialOptions, DeviceCodeCredentialOptions, InteractiveBrowserCredentialOptions and SharedTokenCacheCredentialOptions which when set to true allows the credential to fall back to storing tokens in an unencrypted file if no OS level user encryption is available when EnablePersistentCache is set to true. Added the property AuthenticationRecord to the option class SharedTokenCacheCredentialOptions to support silent authentication for accounts previously authenticated with an interactive credential. Added option class UsernamePasswordCredentialOptions which supports the options EnablePersistentCache and AllowUnencryptedCache. Breaking Changes Rename type KnownAuthorityHosts to AzureAuthorityHosts Rename property AzureChinaCloud to AzureChina Rename property AzureGermanCloud to AzureGermany Rename property AzureUSGovernment to AzureGovernment Rename property AzureCloud to AzurePublicCloud 1.2.0-preview.5 (2020-07-08) New Features Added options classes ClientCertificateCredentialOptions and ClientSecretCredentialOptions which support the following new option EnablePersistentCache configures these credentials to use a persistent cache shared between credentials which set this option. By default the cache is per credential and in memory only. 1.2.0-preview.4 (2020-06-10) New Features Makes AzureCliCredential, VisualStudioCredential and VisualStudioCodeCredential public to allow direct usage. Added Authenticate methods to UsernamePasswordCredential Fixes and improvements Fix SharedTokenCacheCredential account filter to be case-insensitive (Issue #10816) Update VisualStudioCodeCredential to properly throw CredentialUnavailableException when re-authentication is needed. (Issue #11595) 1.2.0-preview.3 (2020-05-05) New Features First preview of new API for authenticating users with DeviceCodeCredential and InteractiveBrowserCredential Added method Authenticate which pro-actively interacts with the user to authenticate if necessary and returns a serializable AuthenticationRecord Added Options classes DeviceCodeCredentialOptions and InteractiveBrowserCredentialOptions which support the following new options AuthenticationRecord enables initializing a credential with an AuthenticationRecord returned from a prior call to Authenticate DisableAutomaticAuthentication disables automatic user interaction causing the credential to throw an AuthenticationRequiredException when interactive authentication is necessary. EnablePersistentCache configures these credentials to use a persistent cache shared between credentials which set this option. By default the cache is per credential and in memory only. 1.2.0-preview.2 (2020-04-06) New Features Updates DefaultAzureCredential to enable authenticating through Visual Studio Updates DefaultAzureCredential to enable authentication through Visual Studio Code 1.2.0-preview.1 (2020-03-10) New Features Updating DefaultAzureCredential to enable authenticating through the Azure CLI ClientCertificateCredential now supports being constructed with a path to an unencrypted certificate (in either PFX or PEM format) EnvironmentCredential now supports reading a certificate path from AZURE_CLIENT_CERTIFICATE_PATH Fixes and improvements Fix an issue where EnvironmentCredential did not behave correctly when AZURE_USERNAME and AZURE_PASSWORD where set Added KnownAuthorityHosts class to aid in sovereign cloud configuration. 1.1.1 (2020-02-10) Fixes and improvements Fixed UsernamePasswordCredential constructor parameter mishandling Updated ManagedIdentityCredential endpoint discovery to avoid throwing Fixed ManagedIdentityCredential to raise CredentialUnavailableException on 400 return from the service where no identity has been assigned Updated error messaging from DefaultAzureCredential to more easily root cause failures 1.1.0 (2019-11-25) Fixes and improvements Update SharedTokenCacheCredential to filter accounts by tenant id Added SharedTokenCacheCredentialOptions class with properties TenantId and Username Added constructor overload to SharedTokenCacheCredential which accepts SharedTokenCacheCredentialOptions Added property SharedTokenCacheTenantId to DefaultAzureCredentialOptions Support for personal account authentication in DefaultAzureCredential, InteractiveBrowserCredential, and SharedTokenCacheCredential Added InteractiveBrowserTenantId to DefaultAzureCredentialOptions Fixed issue with ManagedIdentityCredential authentication with user assigned identities 1.0.0 (2019-10-29) First stable release of Azure.Identity package. Breaking Changes Rename AzureCredentialOptions -> TokenCredentialOptions Renamed property VerificationUrl -> VerificationUri and changed type from string to Uri Updated ClientSecretCredential class Removed property ClientId Removed property ClientSecret Removed property TenantId Updated ClientCertificateCredential class Removed property ClientId Removed property ClientCertificate Removed property TenantId Updated DefaultAzureCredential class to derive directly from TokenCredential rather than ChainedTokenCredential Updated DefaultAzureCredentialOptions class Renamed property PreferredAccountUsername -> SharedTokenCacheUsername Renamed property IncludeEnvironmentCredential -> ExcludeEnvironmentCredential Renamed property IncludeManagedIdentityCredential -> ExcludeManagedIdentityCredential Renamed property IncludeSharedTokenCacheCredential -> ExcludeSharedTokenCacheCredential Renamed property IncludeInteractiveBrowserCredential -> ExcludeInteractiveBrowserCredential Updated DeviceCodeInfo class Removed property Interval Renamed property VerificationUrl -> VerificationUri and changed type from string to Uri Updated InteractiveBrowserCredential class Reordered constructor parameters tenantId and clientId to be consistent with other credential types Updated SharedTokenCacheCredential class Updated constructor to take TokenCredentialOptions Removed clientId constructor parameter Removed class SharedTokenCacheCredentialOptions Updated exception model across the Azure.Identity library. TokenCredential implementations in the Azure.Identity library now throw exceptions rather than returning default(AccessToken) when no token is obtained Added the CredentialUnavailableExcpetion exception type to distinguish cases when failure to obtain an AccessToken was expected Dependency Changes Adopted Azure.Core 1.0.0 Fixes and improvements Update ManagedIdentityCredential IMDS availability check to handle immediate network failures Added a DefaultAzureCredential constructor overload to enable interactive credential types by default 1.0.0-preview.5 (2019-10-07) Dependency Changes Adopted Azure.Core 1.0.0-preview.9 New Features Added DefaultAzureCredentialOptions for configuring the DefaultAzureCredential authentication flow Added InteractiveBrowserCredential to the DefaultAzureCredential authentication flow, but excluded by default Fixes and improvements Updated InteractiveBrowserCredential and DeviceCodeCredential to optionally accept a tenantId to support non-multitenant applications 1.0.0-preview.4 (2019-09-10) Breaking Changes Modified GetToken abstraction to accept TokenRequest structure rather than string[] for forwards compatibility Dependency Changes Adopted Azure.Core 1.0.0-preview.8 New Features Added SharedTokenCacheCredential to support Single Sign On with developer tooling Updated DefaultAzureCredentialauthentication flow to include the SharedTokenCacheCredential 1.0.0-preview.3 (2019-08-06) Dependency Changes Adopted Azure.Core 1.0.0-preview.7 Adopted Microsoft.Identity.Client 4.1.0 New Features User Principal Authentication Added DeviceCodeCredential class Added InteractiveBrowserCredential class Added UsernamePasswordCredential class Support for Azure SDK ASP .NET Core integration Fixes and improvements Added identity client distributed tracing support 1.0.0-preview.2 (2019-07-02) Fixes and improvements Fix to ManagedIdentityCredential to properly parse expires_on from response 1.0.0-preview.1 (2019-06-27) Version 1.0.0-preview.1 is the first preview of our efforts to create a user-friendly authentication API for Azure SDK client libraries. For more information about preview releases of other Azure SDK libraries, please visit https://aka.ms/azure-sdk-preview1-net. New Features Azure Service Authentication Added DefaultAzureCredential class Added ChainedTokenCredential class Service Principal Authentication Added ClientSecretCredential class Added ClientCertificateCredential class Managed Identity Authentication Added ManagedIdentityCredential class See the documentation for more details. User authentication will be added in an upcoming preview release."
  },
  "packages/Azure.Identity.1.14.2/README.html": {
    "href": "packages/Azure.Identity.1.14.2/README.html",
    "title": "Azure Identity client library for .NET | mysite",
    "summary": "Azure Identity client library for .NET The Azure Identity library provides Microsoft Entra ID (formerly Azure Active Directory) token authentication support across the Azure SDK. It provides a set of TokenCredential implementations that can be used to construct Azure SDK clients that support Microsoft Entra token authentication. Source code | Package (NuGet) | API reference documentation | Microsoft Entra ID documentation Getting started Install the package Install the Azure Identity client library for .NET with NuGet: dotnet add package Azure.Identity Prerequisites An Azure subscription. The Azure CLI can also be useful for authenticating in a development environment, creating accounts, and managing account roles. Authenticate the client When debugging and executing code locally, it's typical for a developer to use their own account for authenticating calls to Azure services. There are several developer tools that can be used to perform this authentication in your development environment. Authenticate via Visual Studio Developers using Visual Studio 2017 or later can authenticate a Microsoft Entra account through the IDE. Apps using DefaultAzureCredential or VisualStudioCredential can then use this account to authenticate calls in their app when running locally. To authenticate in Visual Studio, select the Tools > Options menu to launch the Options dialog. Then navigate to the Azure Service Authentication options to sign in with your Microsoft Entra account. Authenticate via the Azure CLI Developers coding outside of an IDE can also use the Azure CLI to authenticate. Apps using DefaultAzureCredential or AzureCliCredential can then use this account to authenticate calls in their app when running locally. To authenticate with the Azure CLI, run the command az login. For users running on a system with a default web browser, the Azure CLI launches the browser to authenticate the user. For systems without a default web browser, the az login command uses the device code authentication flow. The user can also force the Azure CLI to use the device code flow rather than launching a browser by specifying the --use-device-code argument. Authenticate via the Azure Developer CLI Developers coding outside of an IDE can also use the Azure Developer CLI to authenticate. Apps using DefaultAzureCredential or AzureDeveloperCliCredential can then use this account to authenticate calls in their app when running locally. To authenticate with the Azure Developer CLI, run the command azd auth login. For users running on a system with a default web browser, the Azure Developer CLI launches the browser to authenticate the user. For systems without a default web browser, the azd auth login --use-device-code command uses the device code authentication flow. Authenticate via Azure PowerShell Developers coding outside of an IDE can also use Azure PowerShell to authenticate. Apps using DefaultAzureCredential or AzurePowerShellCredential can then use this account to authenticate calls in their app when running locally. To authenticate with Azure PowerShell, run the command Connect-AzAccount. For users running on a system with a default web browser and version 5.0.0 or later of Azure PowerShell, it launches the browser to authenticate the user. For systems without a default web browser, the Connect-AzAccount command uses the device code authentication flow. The user can also force Azure PowerShell to use the device code flow rather than launching a browser by specifying the UseDeviceAuthentication argument. Key concepts Credentials A credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept credentials when they're constructed. Service clients use those credentials to authenticate requests to the service. The Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers numerous credentials capable of acquiring a Microsoft Entra token to authenticate service requests. Each credential in this library is an implementation of the TokenCredential abstract class in Azure.Core, and any of them can be used to construct service clients capable of authenticating with a TokenCredential. See Credential classes for a complete listing of available credential types. DefaultAzureCredential DefaultAzureCredential simplifies authentication while developing apps that deploy to Azure by combining credentials used in Azure hosting environments with credentials used in local development. For more information, see DefaultAzureCredential overview. Continuation policy As of version 1.10.1, DefaultAzureCredential attempts to authenticate with all developer tool credentials until one succeeds, regardless of any errors previous developer tool credentials experienced. For example, a developer tool credential may attempt to get a token and fail, so DefaultAzureCredential will continue to the next credential in the flow. Deployed service credentials stop the flow with a thrown exception if they're able to attempt token retrieval but don't receive one. Prior to version 1.10.1, developer tool credentials would similarly stop the authentication flow if token retrieval failed. This behavior allows for trying all of the developer tool credentials on your machine while having predictable deployed behavior. Examples Specify a user-assigned managed identity with DefaultAzureCredential Many Azure hosts allow the assignment of a user-assigned managed identity. The following examples demonstrate configuring DefaultAzureCredential to authenticate a user-assigned managed identity when deployed to an Azure host. The sample code uses the credential to authenticate a BlobClient from the Azure.Storage.Blobs client library. It also demonstrates how you can specify a user-assigned managed identity either by a client ID or a resource ID. Client ID To use a client ID, take one of the following approaches: Set the DefaultAzureCredentialOptions.ManagedIdentityClientId property. For example: // When deployed to an Azure host, DefaultAzureCredential will authenticate the specified user-assigned managed identity. string userAssignedClientId = \"<your managed identity client ID>\"; var credential = new DefaultAzureCredential( new DefaultAzureCredentialOptions { ManagedIdentityClientId = userAssignedClientId }); var blobClient = new BlobClient( new Uri(\"https://myaccount.blob.core.windows.net/mycontainer/myblob\"), credential); Set the AZURE_CLIENT_ID environment variable. Resource ID To use a resource ID, set the DefaultAzureCredentialOptions.ManagedIdentityResourceId property. The resource ID takes the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. Because resource IDs can be built by convention, they can be more convenient when there are a large number of user-assigned managed identities in your environment. For example: string userAssignedResourceId = \"<your managed identity resource ID>\"; var credential = new DefaultAzureCredential( new DefaultAzureCredentialOptions { ManagedIdentityResourceId = new ResourceIdentifier(userAssignedResourceId) }); var blobClient = new BlobClient( new Uri(\"https://myaccount.blob.core.windows.net/mycontainer/myblob\"), credential); Define a custom authentication flow with ChainedTokenCredential While DefaultAzureCredential is generally the quickest way to authenticate apps for Azure, you can create a customized chain of credentials to be considered. ChainedTokenCredential enables users to combine multiple credential instances to define a customized chain of credentials. For more information, see ChainedTokenCredential overview. Managed identity support Managed identity authentication is supported either indirectly via DefaultAzureCredential or directly via ManagedIdentityCredential for the following Azure services: Azure App Service and Azure Functions Azure Arc Azure Cloud Shell Azure Kubernetes Service Azure Service Fabric Azure Virtual Machines Azure Virtual Machines Scale Sets As of version 1.8.0, ManagedIdentityCredential supports token caching. Sovereign cloud configuration By default, credentials authenticate to the Microsoft Entra endpoint for the Azure Public Cloud. To access resources in other clouds, such as Azure US Government or a private cloud, use one of the following solutions: Configure credentials with the AuthorityHost property. For example: var credential = new DefaultAzureCredential( new DefaultAzureCredentialOptions { AuthorityHost = AzureAuthorityHosts.AzureGovernment }); AzureAuthorityHosts defines authorities for well-known clouds. Set the AZURE_AUTHORITY_HOST environment variable to the appropriate authority host URL. For example, https://login.microsoftonline.us/. Note that this setting affects all credentials in the environment. Use the previous solution to set the authority host on a specific credential. Not all credentials require this configuration. Credentials that authenticate through a developer tool, such as AzureCliCredential, use that tool's configuration. Credential classes Credential chains Credential Usage Reference DefaultAzureCredential Provides a simplified authentication experience to quickly start developing apps run in Azure. DefaultAzureCredential overview ChainedTokenCredential Allows users to define custom authentication flows comprised of multiple credentials. ChainedTokenCredential overview Authenticate Azure-hosted apps Credential Usage Reference EnvironmentCredential Authenticates a service principal or user via credential information specified in environment variables. ManagedIdentityCredential Authenticates the managed identity of an Azure resource. user-assigned managed identity system-assigned managed identity WorkloadIdentityCredential Supports Microsoft Entra Workload ID on Kubernetes. Authenticate service principals Credential Usage Reference AzurePipelinesCredential Supports Microsoft Entra Workload ID on Azure Pipelines. example ClientAssertionCredential Authenticates a service principal using a signed client assertion. ClientCertificateCredential Authenticates a service principal using a certificate. Service principal authentication ClientSecretCredential Authenticates a service principal using a secret. Service principal authentication Authenticate users Credential Usage Reference AuthorizationCodeCredential Authenticates a user with a previously obtained authorization code. OAuth2 authorization code DeviceCodeCredential Interactively authenticates a user on devices with limited UI. Device code authentication InteractiveBrowserCredential Interactively authenticates a user with the default system browser. Interactive browser authentication OnBehalfOfCredential Propagates the delegated user identity and permissions through the request chain. On-behalf-of authentication Authenticate via development tools Credential Usage Reference AzureCliCredential Authenticates in a development environment with the Azure CLI. Azure CLI authentication AzureDeveloperCliCredential Authenticates in a development environment with the Azure Developer CLI. Azure Developer CLI Reference AzurePowerShellCredential Authenticates in a development environment with the Azure PowerShell. Azure PowerShell authentication VisualStudioCredential Authenticates in a development environment with Visual Studio. Visual Studio configuration Note: All credential implementations in the Azure Identity library are threadsafe, and a single credential instance can be used by multiple service clients. Environment variables DefaultAzureCredential and EnvironmentCredential can be configured with environment variables. Each type of authentication requires values for specific variables. Configuration is attempted in the order in which these environment variables are listed. For example, if values for a client secret and certificate are both present, the client secret is used by EnvironmentCredential. Service principal with secret Variable name Value AZURE_CLIENT_ID ID of a Microsoft Entra application AZURE_TENANT_ID ID of the application's Microsoft Entra tenant AZURE_CLIENT_SECRET one of the application's client secrets Service principal with certificate Variable name Value AZURE_CLIENT_ID ID of a Microsoft Entra application AZURE_TENANT_ID ID of the application's Microsoft Entra tenant AZURE_CLIENT_CERTIFICATE_PATH path to a PFX or PEM-encoded certificate file including private key AZURE_CLIENT_CERTIFICATE_PASSWORD (optional) the password protecting the certificate file (currently only supported for PFX (PKCS12) certificates) AZURE_CLIENT_SEND_CERTIFICATE_CHAIN (optional) send certificate chain in x5c header to support subject name / issuer based authentication Workload identity (DefaultAzureCredential) Variable name Value AZURE_CLIENT_ID The client ID of the application the workload identity will authenticate. If defined, used as the default value for WorkloadIdentityClientId in DefaultAzureCredentialOptions. Managed identity (DefaultAzureCredential) Variable name Value AZURE_CLIENT_ID The client ID for the user-assigned managed identity. If defined, used as the default value for ManagedIdentityClientId in DefaultAzureCredentialOptions. Continuous Access Evaluation As of version 1.10.0, accessing resources protected by Continuous Access Evaluation (CAE) is possible on a per-request basis. This behavior can be enabled by setting the IsCaeEnabled property of TokenRequestContext via its constructor. CAE isn't supported for developer credentials. Token caching Token caching is a feature provided by the Azure Identity library. The feature allows apps to: Cache tokens in memory (default) or on disk (opt-in). Improve resilience and performance. Reduce the number of requests made to Microsoft Entra ID to obtain access tokens. The Azure Identity library offers both in-memory and persistent disk caching. For more information, see the token caching documentation. Brokered authentication An authentication broker is an app that runs on a user's machine and manages the authentication handshakes and token maintenance for connected accounts. Currently, only Windows is supported via Web Account Manager (WAM). To enable support, use the Azure.Identity.Broker package. Troubleshooting See the troubleshooting guide. Error handling Errors arising from authentication can be raised on any service client method that makes a request to the service. This is because the first time the token is requested from the credential is on the first call to the service. Any subsequent calls might need to refresh the token. To distinguish these failures from failures in the service client, Azure Identity classes raise the AuthenticationFailedException with details on the error source in the exception message and possibly the error message. Depending upon the app, these errors may or may not be recoverable. using Azure.Identity; using Azure.Security.KeyVault.Secrets; // Create a secret client using the DefaultAzureCredential var client = new SecretClient(new Uri(\"https://myvault.vault.azure.net/\"), new DefaultAzureCredential()); try { KeyVaultSecret secret = await client.GetSecretAsync(\"secret1\"); } catch (AuthenticationFailedException e) { Console.WriteLine($\"Authentication Failed. {e.Message}\"); } For more information on handling errors from failed requests to Microsoft Entra ID or managed identity endpoints, see the Microsoft Entra ID documentation on authorization error codes. Logging See Enable and configure logging. Thread safety We guarantee that all credential instance methods are thread-safe and independent of each other (guideline). This ensures that the recommendation of reusing credential instances is always safe, even across threads. Additional concepts Client options | Accessing the response | Diagnostics | Mocking | Client lifetime Next steps Client libraries supporting authentication with Azure Identity Many of Azure.Core-dependent client libraries support authenticating with TokenCredential and therefore the Azure Identity library. To learn more, see the library-specific docs. Known issues This library doesn't currently support scenarios relating to the Azure AD B2C service. Open issues for the Azure.Identity library can be found here. Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com. When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You'll only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct. For more information, see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments."
  },
  "packages/Microsoft.Bcl.AsyncInterfaces.8.0.0/PACKAGE.html": {
    "href": "packages/Microsoft.Bcl.AsyncInterfaces.8.0.0/PACKAGE.html",
    "title": "| mysite",
    "summary": "About As of C# 8, the C# language has support for producing and consuming asynchronous iterators. The library types in support of those features are available in .NET Core 3.0 and newer as well as in .NET Standard 2.1. This library provides the necessary definitions of those types to support these language features on .NET Framework and on .NET Standard 2.0. This library is not necessary nor recommended when targeting versions of .NET that include the relevant support. Key Features Enables the use of C# async iterators on older .NET platforms How to Use using System; using System.Collections.Generic; using System.Threading.Tasks; internal static class Program { private static async Task Main() { Console.WriteLine(\"Starting...\"); await foreach (var value in GetValuesAsync()) { Console.WriteLine(value); } Console.WriteLine(\"Finished!\"); static async IAsyncEnumerable<int> GetValuesAsync() { for (int i = 0; i < 10; i++) { await Task.Delay(TimeSpan.FromSeconds(1)); yield return i; } } } } Main Types The main types provided by this library are: IAsyncEnumerable<T> IAsyncEnumerator<T> IAsyncDisposable<T> Additional Documentation C# Feature Specification Walkthrough article Feedback & Contributing Microsoft.Bcl.AsyncInterfaces is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Bcl.Cryptography.8.0.0/PACKAGE.html": {
    "href": "packages/Microsoft.Bcl.Cryptography.8.0.0/PACKAGE.html",
    "title": "| mysite",
    "summary": "About This library provides some cryptographic types and functionality for .NET Standard and .NET Framework. This library is not necessary nor recommended when targeting versions of .NET that include the relevant support. Key Features Enables the use of some cryptographic functionality on older .NET platforms. How to Use This package should only be used by platforms where the desired functionality is not built-in. using System.Security.Cryptography; internal static class Program { private static void Main() { byte[] key = LoadKey(); SP800108HmacCounterKdf kbkdf = new(key, HashAlgorithmName.SHA256); byte[] derivedKey = kbkdf.DeriveKey(\"label\"u8, \"context\"u8, derivedKeyLengthInBytes: 32); } } Main Types The main types provided by this library are: System.Security.Cryptography.SP800108HmacCounterKdf Additional Documentation API documentation Feedback & Contributing Microsoft.Bcl.Cryptography is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Data.SqlClient.6.1.3/README.html": {
    "href": "packages/Microsoft.Data.SqlClient.6.1.3/README.html",
    "title": "Microsoft SqlClient Data Provider for SQL Server | mysite",
    "summary": "Microsoft SqlClient Data Provider for SQL Server Microsoft.Data.SqlClient is a .NET data provider for Microsoft SQL Server and the Azure SQL family of databases. It grew from a union of the two System.Data.SqlClient components which live independently in .NET and .NET Framework. Going forward, support for new SQL Server and Azure SQL features will only be implemented in Microsoft.Data.SqlClient. Supportability The Microsoft.Data.SqlClient package supports the following environments: .NET Framework 4.6.2+ .NET 8.0+ Download The Microsoft.Data.SqlClient NuGet package is available on NuGet.org. SNI Package References When targeting .NET Framework on Windows, a package reference to Microsoft.Data.SqlClient.SNI loads native Microsoft.Data.SqlClient.SNI.<platform>.dll libraries into the client's build directories. When targeting .NET on Windows, a package reference to Microsoft.Data.SqlClient.SNI.runtime loads arm64, x64 and x86 native Microsoft.Data.SqlClient.SNI.dll libraries into subdirectories in the client's build directory. Helpful Links Topic Link to File Coding Style coding-style.md Best Practices coding-best-practices.md Review Process review-process.md Guidelines for building the driver BUILDGUIDE.md Guidelines for Contributors CONTRIBUTING.md Changelog for all driver releases CHANGELOG.md Support Policy SUPPORT.md Code of Conduct CODE_OF_CONDUCT.md Copyright Information COPYRIGHT.md Our Featured Contributors Special thanks to everyone who has contributed to the project. We thank you for your continuous support in improving the SqlClient library! Edward Neal (@edwardneal) Erik Ejlskov Jensen (@ErikEJ) Michel Zehnder (@MichelZ) Shay Rojansky (@roji) Phillip Haydon (@phillip-haydon) Rasmus Melchior Jacobsen (@rmja) Robin Sue (@Suchiman) Simon Cropp (@SimonCropp) Stefn Jkull Sigurarson (@stebet) Stephen Toub (@stephentoub) Wraith (@Wraith2) Up-to-date list of contributors: Contributor Insights Release Notes All preview and stable driver release notes are available under release-notes. Porting from System.Data.SqlClient Refer to porting-cheat-sheet.md for a safe porting experience from System.Data.SqlClient to Microsoft.Data.SqlClient and share your experience with us by enhancing this guide for future developers. Still have questions? Check out our FAQ. Still not answered? Create an issue to ask a question. Security Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft, Azure, DotNet, AspNet, Xamarin, and our GitHub organizations. If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability, please report it to us as described below. Reporting Security Issues Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report. If you prefer to submit without logging in, send email to secure@microsoft.com. If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page. You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc. Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs. Preferred Languages We prefer all communications to be in English. Policy Microsoft follows the principle of Coordinated Vulnerability Disclosure. License The Microsoft.Data.SqlClient Driver for SQL Server is licensed under the MIT license. See the LICENSE file for more details. Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft's Trademark & Brand Guidelines. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies."
  },
  "packages/Microsoft.Extensions.Caching.Abstractions.8.0.0/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.Caching.Abstractions.8.0.0/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Provides the abstractions to create and use in-memory and distributed caching in your applications. This library defines how in-memory and distributed caches should be implemented; it doesnt contain any cache implementation. With the abstractions provided in this library, various types of caches can be built and used interchangeably, whether the data is kept in memory, in files, or even across a network. Key Features Interfaces for building and using in-memory and distributed caches. How to Use This package is typically used with an implementation of the caching abstractions, such as Microsoft.Extensions.Caching.Memory or Microsoft.Extensions.Caching.SqlServer. Main Types The main types provided by this library are: Microsoft.Extensions.Caching.Abstractions.ICacheEntry Microsoft.Extensions.Caching.Abstractions.IMemoryCache Microsoft.Extensions.Caching.Abstractions.IDistributedCache Additional Documentation Conceptual documentation API documentation Microsoft.Extensions.Caching.Memory Microsoft.Extensions.Caching.Distributed Related Packages In-memory caching: Microsoft.Extensions.Caching.Memory SQL Server caching: Microsoft.Extensions.Caching.SqlServer Redis caching: Microsoft.Extensions.Caching.StackExchangeRedis Feedback & Contributing Microsoft.Extensions.Caching.Abstractions is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Extensions.Caching.Memory.8.0.1/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.Caching.Memory.8.0.1/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Provides implementations for local and distributed in-memory cache. It stores and retrieves data in a fast and efficient way. Key Features A concrete implementation of the IMemoryCache interface, which represents a local in-memory cache that stores and retrieves data in a fast and efficient way A distributed cache that supports higher scale-out than local cache Expiration and eviction policies for its entries Entry prioritization for when the cache size limit is exceeded and needs to be compacted by entry eviction Track of cache statictics How to Use Use Microsoft.Extensions.Caching.Memory over System.Runtime.Caching when working with ASP.NET Core as it provides better integration support. For example, IMemoryCache works natively with ASP.NET Core dependency injection. Local in-memory serialization: using Microsoft.Extensions.Caching.Memory; using MemoryCache cache = new(new MemoryCacheOptions()); object valueToCache = new(); string key = \"key\"; using (ICacheEntry entry = cache.CreateEntry(key)) { // Entries are committed after they are disposed therefore it does not exist yet. Console.WriteLine($\"Exists: {cache.TryGetValue(key, out _)}\\n\"); entry.Value = valueToCache; entry.SlidingExpiration = TimeSpan.FromSeconds(2); } bool exists = cache.TryGetValue(key, out object? cachedValue); Console.WriteLine($\"Exists: {exists}\" ); Console.WriteLine($\"cachedValue is valueToCache? {object.ReferenceEquals(cachedValue, valueToCache)}\\n\"); Console.WriteLine(\"Wait for the sliding expiration...\"); Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(\"Exists: \" + cache.TryGetValue(key, out _)); // You can also use the acceleration extensions to set and get entries string key2 = \"key2\"; object value2 = new(); cache.Set(\"key2\", value2); object? cachedValue2 = cache.Get(key2); Console.WriteLine($\"cachedValue2 is value2? {object.ReferenceEquals(cachedValue2, value2)}\"); Main Types The main types provided by this library are: Microsoft.Extensions.Caching.Memory.MemoryCache Microsoft.Extensions.Caching.Memory.MemoryCacheOptions Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions Additional Documentation Conceptual documentation Cache in-memory in ASP.NET Core API documentation Related Packages Microsoft.Extensions.Caching.Abstractions Feedback & Contributing Microsoft.Extensions.Caching.Memory is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Extensions.DependencyInjection.Abstractions.8.0.2/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.DependencyInjection.Abstractions.8.0.2/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Supports the lower-level abstractions for the dependency injection (DI) software design pattern which is a technique for achieving Inversion of Control (IoC) between classes and their dependencies. Key Features Interfaces for DI implementations which are provided in other packages including Microsoft.Extensions.DependencyInjection. An implementation of a service collection, which is used to add services to and later retrieve them either directly or through constructor injection. Interfaces, attributes and extensions methods to support various DI concepts including specifying a service's lifetime and supporting keyed services. How to Use This package is typically used with an implementation of the DI abstractions, such as Microsoft.Extensions.DependencyInjection. Main Types The main types provided by this library are: Microsoft.Extensions.DependencyInjection.ActivatorUtilities Microsoft.Extensions.DependencyInjection.IServiceCollection Microsoft.Extensions.DependencyInjection.ServiceCollection Microsoft.Extensions.DependencyInjection.ServiceCollectionDescriptorExtensions Microsoft.Extensions.DependencyInjection.ServiceDescriptor Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TContainerBuilder> Additional Documentation Conceptual documentation API documentation ActivatorUtilities ServiceCollection ServiceDescriptor Related Packages Microsoft.Extensions.DependencyInjection Microsoft.Extensions.Hosting Microsoft.Extensions.Options Feedback & Contributing Microsoft.Extensions.DependencyInjection.Abstractions is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Extensions.Logging.Abstractions.8.0.3/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.Logging.Abstractions.8.0.3/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Microsoft.Extensions.Logging.Abstractions provides abstractions of logging. Interfaces defined in this package are implemented by classes in Microsoft.Extensions.Logging and other logging packages. This package includes a logging source generator that produces highly efficient and optimized code for logging message methods. Key Features Define main logging abstraction interfaces like ILogger, ILoggerFactory, ILoggerProvider, etc. How to Use Custom logger provider implementation example using Microsoft.Extensions.Logging; public sealed class ColorConsoleLogger : ILogger { private readonly string _name; private readonly Func<ColorConsoleLoggerConfiguration> _getCurrentConfig; public ColorConsoleLogger( string name, Func<ColorConsoleLoggerConfiguration> getCurrentConfig) => (_name, _getCurrentConfig) = (name, getCurrentConfig); public IDisposable? BeginScope<TState>(TState state) where TState : notnull => default!; public bool IsEnabled(LogLevel logLevel) => _getCurrentConfig().LogLevelToColorMap.ContainsKey(logLevel); public void Log<TState>( LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter) { if (!IsEnabled(logLevel)) { return; } ColorConsoleLoggerConfiguration config = _getCurrentConfig(); if (config.EventId == 0 || config.EventId == eventId.Id) { ConsoleColor originalColor = Console.ForegroundColor; Console.ForegroundColor = config.LogLevelToColorMap[logLevel]; Console.WriteLine($\"[{eventId.Id,2}: {logLevel,-12}]\"); Console.ForegroundColor = originalColor; Console.Write($\" {_name} - \"); Console.ForegroundColor = config.LogLevelToColorMap[logLevel]; Console.Write($\"{formatter(state, exception)}\"); Console.ForegroundColor = originalColor; Console.WriteLine(); } } } Create logs // Worker class that uses logger implementation of teh interface ILogger<T> public sealed class Worker : BackgroundService { private readonly ILogger<Worker> _logger; public Worker(ILogger<Worker> logger) => _logger = logger; protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { _logger.LogInformation(\"Worker running at: {time}\", DateTimeOffset.UtcNow); await Task.Delay(1_000, stoppingToken); } } } Use source generator public static partial class Log { [LoggerMessage( EventId = 0, Level = LogLevel.Critical, Message = \"Could not open socket to `{hostName}`\")] public static partial void CouldNotOpenSocket(this ILogger logger, string hostName); } public partial class InstanceLoggingExample { private readonly ILogger _logger; public InstanceLoggingExample(ILogger logger) { _logger = logger; } [LoggerMessage( EventId = 0, Level = LogLevel.Critical, Message = \"Could not open socket to `{hostName}`\")] public partial void CouldNotOpenSocket(string hostName); } Main Types The main types provided by this library are: Microsoft.Extensions.Logging.ILogger Microsoft.Extensions.Logging.ILoggerProvider Microsoft.Extensions.Logging.ILoggerFactory Microsoft.Extensions.Logging.ILogger<TCategoryName> Microsoft.Extensions.Logging.LogLevel Microsoft.Extensions.Logging.Logger<T> Microsoft.Extensions.Logging.LoggerMessage Microsoft.Extensions.Logging.Abstractions.NullLogger Additional Documentation Conceptual documentation API documentation Related Packages Microsoft.Extensions.Logging Microsoft.Extensions.Logging.Console Microsoft.Extensions.Logging.Debug Microsoft.Extensions.Logging.EventSource Microsoft.Extensions.Logging.EventLog Microsoft.Extensions.Logging.TraceSource Feedback & Contributing Microsoft.Extensions.Logging.Abstractions is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Extensions.Options.8.0.2/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.Options.8.0.2/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Microsoft.Extensions.Options provides a strongly typed way of specifying and accessing settings using dependency injection and acts as a bridge between configuration, DI, and higher level libraries. This library is the glue for how an app developer uses DI to configure the behavior of a library like HttpClient Factory. This also enables user to get a strongly-typed view of their configuration. Within this package, you'll find an options validation source generator that generates exceptionally efficient and optimized code for validating options. Key Features Offer the IValidateOptions interface for the validation of options, along with several generic ValidateOptions classes that implement this interface. OptionsBuilder to configure options. Provide extension methods for service collections and options builder to register options and validate options. Supply a set of generic ConfigureNamedOptions classes that implement the IConfigureNamedOptions interface for configuring named options. Provide a source generator that generates validation code for options. Options caching, managing and monitoring. How to Use Options validation example using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Options; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllersWithViews(); // Load the configuration and validate it builder.Services.AddOptions<MyConfigOptions>() .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig)) .ValidateDataAnnotations(); var app = builder.Build(); // Declare the option class to validate public class MyConfigOptions { public const string MyConfig = \"MyConfig\"; [RegularExpression(@\"^[a-zA-Z''-'\\s]{1,40}$\")] public string Key1 { get; set; } [Range(0, 1000, ErrorMessage = \"Value for {0} must be between {1} and {2}.\")] public int Key2 { get; set; } public int Key3 { get; set; } } Using IValidateOptions to validate options using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Options; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllersWithViews(); // Configuration to validate builder.Services.Configure<MyConfigOptions>(builder.Configuration.GetSection( MyConfigOptions.MyConfig)); // OPtions validation through the DI container builder.Services.AddSingleton<IValidateOptions <MyConfigOptions>, MyConfigValidation>(); var app = builder.Build(); public class MyConfigValidation : IValidateOptions<MyConfigOptions> { public MyConfigOptions _config { get; private set; } public MyConfigValidation(IConfiguration config) { _config = config.GetSection(MyConfigOptions.MyConfig) .Get<MyConfigOptions>(); } public ValidateOptionsResult Validate(string name, MyConfigOptions options) { string? vor = null; var rx = new Regex(@\"^[a-zA-Z''-'\\s]{1,40}$\"); var match = rx.Match(options.Key1!); if (string.IsNullOrEmpty(match.Value)) { vor = $\"{options.Key1} doesn't match RegEx \\n\"; } if ( options.Key2 < 0 || options.Key2 > 1000) { vor = $\"{options.Key2} doesn't match Range 0 - 1000 \\n\"; } if (_config.Key2 != default) { if(_config.Key3 <= _config.Key2) { vor += \"Key3 must be > than Key2.\"; } } if (vor != null) { return ValidateOptionsResult.Fail(vor); } return ValidateOptionsResult.Success; } } Options Validation Source Generator Example using System; using System.ComponentModel.DataAnnotations; using Microsoft.Extensions.Options; public class MyConfigOptions { [RegularExpression(@\"^[a-zA-Z''-'\\s]{1,40}$\")] public string Key1 { get; set; } [Range(0, 1000, ErrorMessage = \"Value for {0} must be between {1} and {2}.\")] public int Key2 { get; set; } public int Key3 { get; set; } } [OptionsValidator] public partial class MyConfigValidation : IValidateOptions<MyConfigOptions> { // Source generator will automatically provide the implementation of IValidateOptions // Then you can add the validation to the DI Container using the following code: // // builder.Services.AddSingleton<IValidateOptions // <MyConfigOptions>, MyConfigValidation>(); // builder.Services.AddOptions<MyConfigOptions>() // .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig)) // .ValidateDataAnnotations(); } Main Types The main types provided by this library are: IOptions, IOptionsFactory, and IOptionsMonitor IValidateOptions and ValidateOptions OptionsBuilder, OptionsFactory, OptionsMonitor, and OptionsManager OptionsServiceCollectionExtensions OptionsValidatorAttribute Additional Documentation Conceptual documentation API documentation Related Packages Microsoft.Extensions.Logging Microsoft.Extensions.Configuration Feedback & Contributing Microsoft.Extensions.Options is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Extensions.Primitives.8.0.0/PACKAGE.html": {
    "href": "packages/Microsoft.Extensions.Primitives.8.0.0/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Microsoft.Extensions.Primitives contains isolated types that are used in many places within console or ASP.NET Core applications using framework extensions. Key Features IChangeToken: An interface that represents a token that can notify when a change occurs. This can be used to trigger actions or invalidate caches when something changes. For example, the configuration and file providers libraries use this interface to reload settings or files when they are modified. StringValues: A struct that represents a single string or an array of strings. This can be used to efficiently store and manipulate multiple values that are logically a single value. For example, the HTTP headers and query strings libraries use this struct to handle multiple values for the same key. StringSegment: A struct that represents a substring of another string. This can be used to avoid allocating new strings when performing operations on parts of a string. For example, the configuration and logging libraries use this struct to parse and format strings. How to Use IChangeToken with configuration example using Microsoft.Extensions.Configuration; using Microsoft.Extensions.Primitives; using System; class Program { static void Main(string[] args) { // Create a configuration builder var configurationBuilder = new ConfigurationBuilder() .SetBasePath(Environment.CurrentDirectory) // appsettings.json expected to have the following contents: // { // \"SomeKey\": \"SomeValue\" // } .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true); // Build the configuration IConfiguration configuration = configurationBuilder.Build(); // Create a change token for the configuration IChangeToken changeToken = configuration.GetReloadToken(); // Attach a change callback IDisposable changeTokenRegistration = changeToken.RegisterChangeCallback(state => { Console.WriteLine(\"Configuration changed!\"); IConfigurationRoot root = (IConfigurationRoot)state; var someValue = root[\"SomeKey\"]; // Access the updated configuration value Console.WriteLine($\"New value of SomeKey: {someValue}\"); }, configuration); // go and update the value of the key SomeKey in appsettings.json. // The change callback will be invoked when the file is saved. Console.WriteLine(\"Listening for configuration changes. Press any key to exit.\"); Console.ReadKey(); // Clean up the change token registration when no longer needed changeTokenRegistration.Dispose(); } } StringValues example using System; using Microsoft.Extensions.Primitives; namespace StringValuesSample { class Program { static void Main(string[] args) { // Create a StringValues object from a single string or an array of strings StringValues single = \"Hello\"; StringValues multiple = new string[] { \"Hello\", \"World\" }; // Use the implicit conversion to string or the ToString method to get the values Console.WriteLine($\"Single: {single}\"); // Single: Hello Console.WriteLine($\"Multiple: {multiple}\"); // Multiple: Hello,World // Use the indexer, the Count property, and the IsNullOrEmpty method to access the values Console.WriteLine($\"Multiple[1]: {multiple[1]}\"); // Multiple[1]: World Console.WriteLine($\"Single.Count: {single.Count}\"); // Single.Count: 1 Console.WriteLine($\"Multiple.IsNullOrEmpty: {StringValues.IsNullOrEmpty(multiple)}\"); // Multiple.IsNullOrEmpty: False // Use the Equals method or the == operator to compare two StringValues objects Console.WriteLine($\"single == \\\"Hello\\\": {single == \"Hello\"}\"); // single == \"Hello\": True Console.WriteLine($\"multiple == \\\"Hello\\\": {multiple == \"Hello\"}\"); // multiple == \"Hello\": False } } } Main Types The main types provided by this library are: IChangeToken StringValues StringSegment Additional Documentation Conceptual documentation API documentation Related Packages Microsoft.Extensions.Configuration Feedback & Contributing Microsoft.Extensions.Primitives is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/Microsoft.Identity.Client.4.73.1/README.html": {
    "href": "packages/Microsoft.Identity.Client.4.73.1/README.html",
    "title": "Microsoft Authentication Library (MSAL) for .NET | mysite",
    "summary": "Microsoft Authentication Library (MSAL) for .NET The MSAL library for .NET is part of the Microsoft identity platform for developers (formerly named Azure AD) v2.0. It enables you to acquire security tokens to call protected APIs. It uses industry standard OAuth2 and OpenID Connect. The library also supports Azure AD B2C. Quick links: Conceptual documentation Getting Started Sample Code API Reference Support Feedback NuGet Package Version Lifecycle and Support Matrix See Long Term Support policy for details. The following table lists MSAL.NET versions currently supported and receiving security fixes. Major Version Last Release Patch Release Date Support Phase End of Support 4.x Monthly Active Not planned. Supported versions: from 4.61.2 to Unsupported versions < 4.61.2. Performance perspectives Our documentation describes the approach to performance testing. View some of the historical performance benchmark results in our dashboard. Support SLA MSAL.NET became Generally Available with MSAL.NET 3.0.8. Since MSAL.NET moved to version 4: Major versions are supported for twelve months after the release of the next major version. Minor versions older than N-1 are not supported. Note Minor versions include bug fixes or features with non-breaking (additive) API changes. It is expected that applications using the library can upgrade through the IDE or CLI with no friction. We will not patch old minor versions of the library. When opening new issues, please confirm that you are using the latest minor version. Using MSAL.NET Guides, tutorials, and detailed walkthroughs are available on Microsoft Learn. API documentation is available on Microsoft Learn Code samples are available from our Samples page. Where do I file issues You can file new issues in this repository. Community help and support We use Stack Overflow with the community to provide support. We highly recommend you ask your questions on Stack Overflow first and browse existing issues to see if someone has asked your question before. If you find a bug or have a feature request, please raise the issue on GitHub Issues. Contribute We welcome contributions and feedback. You can fork and clone the repo and start contributing now. Read our Contribution Guide for more information. This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Security library This library controls how users sign-in and access services. We recommend you always take the latest version of our library in your app when possible. We use semantic versioning so you can control the risk associated with updating your app. As an example, always downloading the latest minor version number (e.g. x.y.z) ensures you get the latest security and feature enhancements but our API surface remains the same. You can always see the latest version and release notes under the Releases tab of GitHub. Security reporting If you find a security issue with our libraries or services please report it to secure@microsoft.com in as much detail as possible. Your submission may be eligible for a bounty through the Microsoft Bug Bounty program. Please do not post security issues to GitHub Issues or any other public site. We will contact you shortly after receiving the information. We encourage you to get notifications of when security incidents occur by visiting the Microsoft Technical Security Notifications page and subscribing to Security Advisory Alerts. Data collection The software may collect information about you and your use of the software and send it to Microsoft. Microsoft may use this information to provide services and improve our products and services. You may turn off the telemetry as described in the repository. There are also some features in the software that may enable you and Microsoft to collect data from users of your applications. If you use these features, you must comply with applicable law, including providing appropriate notices to users of your applications together with a copy of Microsoft's privacy statement. Our privacy statement is located at https://go.microsoft.com/fwlink/?LinkID=824704. You can learn more about data collection and use in the help documentation and our privacy statement. Your use of the software operates as your consent to these practices. See the our telemetry documentation for an example of the telemetry collected by MSAL.NET. Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft's Trademark & Brand Guidelines. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies. Copyright  Microsoft Corporation. All rights reserved. Licensed under the MIT License (the \"License\")."
  },
  "packages/Microsoft.Identity.Client.Extensions.Msal.4.73.1/README.html": {
    "href": "packages/Microsoft.Identity.Client.Extensions.Msal.4.73.1/README.html",
    "title": "Microsoft Authentication Library (MSAL) for .NET | mysite",
    "summary": "Microsoft Authentication Library (MSAL) for .NET The MSAL library for .NET is part of the Microsoft identity platform for developers (formerly named Azure AD) v2.0. It enables you to acquire security tokens to call protected APIs. It uses industry standard OAuth2 and OpenID Connect. The library also supports Azure AD B2C. Quick links: Conceptual documentation Getting Started Sample Code API Reference Support Feedback NuGet Package Version Lifecycle and Support Matrix See Long Term Support policy for details. The following table lists MSAL.NET versions currently supported and receiving security fixes. Major Version Last Release Patch Release Date Support Phase End of Support 4.x Monthly Active Not planned. Supported versions: from 4.61.2 to Unsupported versions < 4.61.2. Performance perspectives Our documentation describes the approach to performance testing. View some of the historical performance benchmark results in our dashboard. Support SLA MSAL.NET became Generally Available with MSAL.NET 3.0.8. Since MSAL.NET moved to version 4: Major versions are supported for twelve months after the release of the next major version. Minor versions older than N-1 are not supported. Note Minor versions include bug fixes or features with non-breaking (additive) API changes. It is expected that applications using the library can upgrade through the IDE or CLI with no friction. We will not patch old minor versions of the library. When opening new issues, please confirm that you are using the latest minor version. Using MSAL.NET Guides, tutorials, and detailed walkthroughs are available on Microsoft Learn. API documentation is available on Microsoft Learn Code samples are available from our Samples page. Where do I file issues You can file new issues in this repository. Community help and support We use Stack Overflow with the community to provide support. We highly recommend you ask your questions on Stack Overflow first and browse existing issues to see if someone has asked your question before. If you find a bug or have a feature request, please raise the issue on GitHub Issues. Contribute We welcome contributions and feedback. You can fork and clone the repo and start contributing now. Read our Contribution Guide for more information. This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Security library This library controls how users sign-in and access services. We recommend you always take the latest version of our library in your app when possible. We use semantic versioning so you can control the risk associated with updating your app. As an example, always downloading the latest minor version number (e.g. x.y.z) ensures you get the latest security and feature enhancements but our API surface remains the same. You can always see the latest version and release notes under the Releases tab of GitHub. Security reporting If you find a security issue with our libraries or services please report it to secure@microsoft.com in as much detail as possible. Your submission may be eligible for a bounty through the Microsoft Bug Bounty program. Please do not post security issues to GitHub Issues or any other public site. We will contact you shortly after receiving the information. We encourage you to get notifications of when security incidents occur by visiting the Microsoft Technical Security Notifications page and subscribing to Security Advisory Alerts. Data collection The software may collect information about you and your use of the software and send it to Microsoft. Microsoft may use this information to provide services and improve our products and services. You may turn off the telemetry as described in the repository. There are also some features in the software that may enable you and Microsoft to collect data from users of your applications. If you use these features, you must comply with applicable law, including providing appropriate notices to users of your applications together with a copy of Microsoft's privacy statement. Our privacy statement is located at https://go.microsoft.com/fwlink/?LinkID=824704. You can learn more about data collection and use in the help documentation and our privacy statement. Your use of the software operates as your consent to these practices. See the our telemetry documentation for an example of the telemetry collected by MSAL.NET. Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft's Trademark & Brand Guidelines. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies. Copyright  Microsoft Corporation. All rights reserved. Licensed under the MIT License (the \"License\")."
  },
  "packages/Microsoft.SqlServer.Types.170.1000.7/license.html": {
    "href": "packages/Microsoft.SqlServer.Types.170.1000.7/license.html",
    "title": "| mysite",
    "summary": "MICROSOFT PRE-RELEASE SOFTWARE LICENSE TERMS MICROSOFT SQL SERVER VNEXT COMMUNITY PREVIEW These license terms are an agreement between Microsoft Corporation (or based on where you live, one of its affiliates) and you. Please read them. They apply to the pre-release software named above, which includes the media on which you received it, if any. The terms also apply to any Microsoft updates, supplements, Internet-based services, and support services for this software, unless other terms accompany those items. If so, those terms apply. BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS. YOU MAY CHOOSE NOT TO ACCEPT THESE TERMS, IN WHICH CASE YOU MAY NOT USE THE SOFTWARE (IF YOU HAVE NOT ALREADY INSTALLED IT) OR WITHDRAW YOUR ACCEPTANCE ANY TIME BY UNINSTALLING THE SOFTWARE. If you comply with these license terms, you have the rights below. INSTALLATION AND USE RIGHTS. Installation and Use. You may install any number of copies of the software on your premises solely to internally evaluate it and provide feedback to Microsoft. You may not test the software in a live operating environment unless Microsoft permits you to do so under another agreement. Third Party Programs. The software may include third party programs that Microsoft, not the third party, licenses to you under this agreement. Notices, if any, for the third party program are included for your information only. Additionally, any third party scripts, linked to, called or referenced from this software, are licensed to you by the third parties that own such code, not by Microsoft. TERM. The term of this agreement is until 09/30/2022. PRE-RELEASE SOFTWARE. This software is a pre-release version. It may not work the way a final version of the software will. We may change it for the final, commercial version. We also may not release a commercial version. UPDATES. The software may install automatic updates, which cannot be turned off. By using the software, you agree to receive automatic updates without any additional notice, and permit Microsoft to download and install them for you. You agree to obtain these updates only from Microsoft or Microsoft authorized sources. If you do not want software updates, disconnect your device from the internet or uninstall the software. FEEDBACK. If you give feedback about the software to Microsoft, you give to Microsoft, without charge, the right to use, share and commercialize your feedback in any way and for any purpose. You also give to third parties, without charge, any patent rights needed for their products, technologies and services to use or interface with any specific parts of a Microsoft software or service that includes the feedback. You will not give feedback that is subject to a license that requires Microsoft to license its software or documentation to third parties because we include your feedback in them. These rights survive this agreement. SCOPE OF LICENSE. The software is licensed, not sold. This agreement only gives you some rights to use the software. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you may use the software only as expressly permitted in this agreement. In doing so, you must comply with any technical limitations in the software that only allow you to use it in certain ways. You may not disclose the results of any benchmark tests of the software to any third party without Microsofts prior written approval; work around any technical limitations in the software; reverse engineer, decompile or disassemble the software, except and only to the extent that applicable law expressly permits, despite this limitation; make more copies of the software than specified in this agreement or allowed by applicable law, despite this limitation; publish the software for others to copy; rent, lease or lend the software; transfer the software or this agreement to any third party; or use the software for commercial software hosting services. EXPORT RESTRICTIONS. The software is subject to United States export laws and regulations. You must comply with all domestic and international export laws and regulations that apply to the software. These laws include restrictions on destinations, end users and end use. For additional information, see www.microsoft.com/exporting. SUPPORT SERVICES. Because this software is as is, we may not provide support services for it. ENTIRE AGREEMENT. This agreement, and the terms for supplements, updates, Internet-based services and support services that you use, are the entire agreement for the software and support services. APPLICABLE LAW. United States. If you acquired the software in the United States, Washington state law governs the interpretation of this agreement and applies to claims for breach of it, regardless of conflict of laws principles. The laws of the state where you live govern all other claims, including claims under state consumer protection laws, unfair competition laws, and in tort. Outside the United States. If you acquired the software in any other country, the laws of that country apply. LEGAL EFFECT. This agreement describes certain legal rights. You may have other rights under the laws of your country. You may also have rights with respect to the party from whom you acquired the software. This agreement does not change your rights under the laws of your country if the laws of your country do not permit it to do so. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED AS-IS. YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES OR CONDITIONS. YOU MAY HAVE ADDITIONAL CONSUMER RIGHTS OR STATUTORY GUARANTEES UNDER YOUR LOCAL LAWS WHICH THIS AGREEMENT CANNOT CHANGE. TO THE EXTENT PERMITTED UNDER YOUR LOCAL LAWS, MICROSOFT EXCLUDES THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. FOR AUSTRALIA  YOU HAVE STATUTORY GUARANTEES UNDER THE AUSTRALIAN CONSUMER LAW AND NOTHING IN THESE TERMS IS INTENDED TO AFFECT THOSE RIGHTS. 13. LIMITATION ON AND EXCLUSION OF REMEDIES AND DAMAGES. YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT OR INCIDENTAL DAMAGES. This limitation applies to anything related to the software, services, content (including code) on third party Internet sites, or third party programs; and claims for breach of contract, breach of warranty, guarantee or condition, strict liability, negligence, or other tort to the extent permitted by applicable law. It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your country may not allow the exclusion or limitation of incidental, consequential or other damages. Please note: As this software is distributed in Quebec, Canada, these license terms are provided below in French. Remarque : Ce logiciel tant distribu au Qubec, Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en franais. EXCLUSIONS DE GARANTIE. Le logiciel est concd sous licence  en ltat . Vous assumez tous les risques lis  son utilisation. Microsoft naccorde aucune garantie ou condition expresse. Vous pouvez bnficier de droits des consommateurs supplmentaires dans le cadre du droit local, que ce contrat ne peut modifier. Lorsque cela est autoris par le droit local, Microsoft exclut les garanties implicites de qualit, dadquation  un usage particulier et dabsence de contrefaon. LIMITATION ET EXCLUSION DE RECOURS ET DE DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs limite uniquement  hauteur de 5,00 $ US. Vous ne pouvez prtendre  aucune indemnisation pour les autres dommages, y compris les dommages spciaux, indirects ou accessoires et pertes de bnfices. Cette limitation concerne : toute affaire lie au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers et les rclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilit stricte, de ngligence ou dune autre faute dans la limite autorise par la loi en vigueur. Elle sapplique galement mme si Microsoft connaissait l'ventualit d'un tel dommage. La limitation ou exclusion ci-dessus peut galement ne pas vous tre applicable, car votre pays nautorise pas lexclusion ou la limitation de responsabilit pour les dommages indirects, accessoires ou de quelque nature que ce soit. EFFET JURIDIQUE. Le prsent contrat dcrit certains droits juridiques. Vous pourriez avoir dautres droits prvus par les lois de votre pays. Le prsent contrat ne modifie pas les droits que vous confrent les lois de votre pays si celles-ci ne le permettent pas."
  },
  "packages/System.ClientModel.1.5.1/CHANGELOG.html": {
    "href": "packages/System.ClientModel.1.5.1/CHANGELOG.html",
    "title": "Release History | mysite",
    "summary": "Release History 1.5.1 (2025-07-14) Bugs Fixed Fixed an issue where System.ClientModel.SourceGeneration was running slowly for large projects with many dependencies. Breaking Changes The System.ClientModel.SourceGeneration used to auto-discover IJsonModel<T>'s that were in the project as well as any types T used in ModelReaderWriter.Read<T> and ModelReaderWriter.Write<T>. Now you must explicitly add a ModelReaderWriterBuildableAttribute with each type that needs to have AOT friendly reading and writing. 1.5.0 (2025-07-07) Features Added Added the following types for 3rd-party Authentication support: AuthenticationTokenProvider, GetTokenOptions, AuthenticationToken, AuthenticationPolicy, and BearerTokenPolicy. Breaking Changes Source Breaking Change: Updated IJsonModel<T>.Create and IPersistableModel<T>.Create method return types from T to T? to allow returning null when deserialization fails. This change only affects code with nullable reference types enabled. For consumers calling these methods: To fix compilation errors, either: Use null-conditional operators (?.) when calling these methods, or Add null-forgiving operators (!) if you're certain the result won't be null, or Add explicit null checks before using the returned value For implementers of these interfaces: Update method signatures in your models to return T? instead of T, and decide whether to return null or throw exceptions in error scenarios 1.5.0-beta.1 (2025-06-13) Features Added Added the following types for 3rd-party Authentication support: AuthenticationTokenProvider, GetTokenOptions, AuthenticationToken, AuthenticationPolicy, and BearerTokenPolicy. 1.4.2 (2025-06-05) Bugs Fixed First part of performance improvements for System.ClientModel.SourceGeneration to shorten lengthy builds. 1.4.1 (2025-05-09) Bugs Fixed Fixed an issue when a model builder was both IEnumerable and IPersistable. 1.4.0 (2025-05-02) Features Added Added additional supported scenarios to System.ClientModel.SourceGeneration. Other Changes Upgraded versions of dependencies on System.Diagnostics.DiagnosticSource, System.Text.Json, and Microsoft.Extensions.Logging.Abstractions. Renamed ActivityExtensions.MarkFailed to ActivityExtensions.MarkClientActivityFailed. Made int maxSize parameter to ClientCache constructor required and removed default value. Changed IEquatable<object> clientId parameter to object clientId in ClientCache.GetClient Renamed ConnectionCollection to ClientConnectionCollection Renamed ConnectionProvider to ClientConnectionProvider Renamed ToCollection to ConvertCollectionBuilder in ModelReadWriteTypeBuilder Renamed AddKeyValuePair to AddItemWithKey in ModelReadWriteTypeBuilder 1.4.0-beta.6 (2025-04-28) Features Added Added additional supported scenarios to System.ClientModel.SourceGeneration. 1.4.0-beta.5 (2025-04-23) Features Added Added additional supported scenarios to System.ClientModel.SourceGeneration. 1.4.0-beta.4 (2025-04-21) Features Added Added additional supported scenarios to System.ClientModel.SourceGeneration. 1.4.0-beta.3 (2025-04-16) Bugs Fixed System.ClientModel.SourceGeneration adds the Default property even when no type builders exist. 1.4.0-beta.2 (2025-04-14) Features Added Added extensions to System.Diagnostics.Activity and System.Diagnostics.ActivitySource to simplify instrumentation of client libraries Added new overloads to System.ClientModel.ModelReaderWriter which take in a new ModelReaderWriterContext which allows reading and writing of collections of IPersistableModel<>. In addition any calls to the new overloads are AOT compatible. 1.4.0-beta.1 (2025-03-06) Features Added Added new connection management types in the System.ClientModel.Primitives namespace: ConnectionProvider: Abstract base class for managing client connections, including retrieval of connection settings and subclient caching. ClientConnection: Readonly struct that encapsulates connection options with support for API key, token, or no authentication. ConnectionCollection: A keyed collection of client connections, supporting JSON serialization and providing an enhanced debugger view. ClientCache: Implements an LRU-based cache for efficient reuse of client instances and optimized retrieval. Bugs Fixed Removed debugging statement in pipeline creation when applying the ClientLoggingOptions.AllowedHeaderNames option. 1.3.0 (2025-02-11) Features Added Added default logging with sanitization to Event Source. Added new logging options type to configure logging behavior, disable all logging, or opt to use ILogger instead. Other Changes Use BinaryData.Empty for PipelineResponse.Content when HTTP message has no content (#46669). 1.2.1 (2024-10-09) Bugs Fixed Upgraded System.Text.Json package dependency to 6.0.10 for security fix (#46134). 1.2.0 (2024-10-03) Other Changes Upgraded System.Memory.Data package dependency to 6.0.0 (#46134). 1.1.0 (2024-09-17) Other Changes Removed implicit cast from string to ApiKeyCredential (#45554). Upgraded System.Text.Json package dependency to 6.0.9 (#45416). Removed PageCollection<T> and related types in favor of using CollectionResult<T> and related types as the return values from paginated service endpoints (#45961). 1.1.0-beta.7 (2024-08-14) Features Added Added JsonModelConverter to allow integration with System.Text.Json. Other Changes Removed ReturnWhen enum in favor of using bool waitUntilCompleted parameter in third-party client LRO method signatures. Added abstract UpdateStatus method to OperationResult. 1.1.0-beta.6 (2024-08-01) Features Added Added OperationResult and ReturnWhen types to support long-running operations. Bugs Fixed Added support for delaying retrying a request until after the interval specified on a response Retry-After header. 1.1.0-beta.5 (2024-07-11) Features Added Added AsyncPageCollection<T> and PageCollection<T> types as return types from paginated service operations, and ContinuationToken type for resuming collection state across processes. Other Changes Renamed AsyncResultCollection<T> and ResultCollection<T> to AsyncCollectionResult<T> and CollectionResult<T> to standardize use of the Result suffix in type names. Removed AsyncPageableCollection<T> and PageableCollection<T> that previously represented collections of items rather than collections of pages of items, and renamed ResultPage<T> to PageResult<T>. 1.1.0-beta.4 (2024-05-16) Features Added Added BufferResponse property to RequestOptions so protocol method callers can turn off response buffering if desired. Added AsyncResultCollection<T> and ResultCollection<T> for clients to return from service methods where the service response contains a collection of values. Added AsyncPageableCollection<T>, PageableCollection<T> and ResultPage<T> for clients to return from service methods where collection values are delivered to the client over one or more service responses. Added SetRawResponse method to ClientResult to allow the response held by the result to be changed, for example by derived types that obtain multiple responses from polling the service. Other Changes ClientResult.GetRawResponse will now throw InvalidOperationException if called before the result's raw response is set, for example by collection result types that delay sending a request to the service until the collection is enumerated. 1.1.0-beta.3 (2024-04-04) Features Added Added protected Apply(PipelineMessage) method to RequestOptions so that derived types can extend its functionality. Added Create(Stream) overload to BinaryContent. Other Changes Removed [Serializable] attribute and serialization constructor from ClientResultException. Made value parameter nullable in PipelineMessage.SetProperty method. Made options parameter to PipelineMessage.Apply nullable. 1.1.0-beta.2 (2024-02-29) Features Added Added ExtractResponse method to PipelineMessage to enable returning an undisposed PipelineResponse from protocol methods. Added CreateAsync factory method to ClientResultException to allow creating exceptions in an async context. Added an implicit cast from string to ApiKeyCredential. Added an implicit cast from ClientResult<T> to T. Other Changes Changed HttpClientPipelineTransport.Shared and ClientRetryPolicy.Default from static readonly fields to static properties. Changed PipelineResponse.Content property from abstract to virtual. Removed the ResponseBufferingPolicy and moved response buffering functionality into PipelineTransport. Made CancellationToken parameter passed to BinaryContent.WriteTo optional. 1.1.0-beta.1 (2024-02-01) Features Added Initial preview release of convenience types in the System.ClientModel namespace, including ClientResult<T>, KeyCredential, and ClientResultException. Initial preview release of pipeline types, including ClientPipeline, PipelinePolicy, and PipelineMessage. 1.0.0 (2024-01-03) Features Added Initial release of ModelReaderWriter APIs for reading and writing models in different formats. 1.0.0-beta.2 (2023-12-14) Other Changes ModelReaderWriter and ModelReaderWriterOptions have moved to System.ClientModel.Primitives namespace JsonModelConverter was removed. 1.0.0-beta.1 (2023-11-22) Features Added ModelReaderWriter APIs for reading and writing models in different formats."
  },
  "packages/System.ClientModel.1.5.1/README.html": {
    "href": "packages/System.ClientModel.1.5.1/README.html",
    "title": "System.ClientModel library for .NET | mysite",
    "summary": "System.ClientModel library for .NET System.ClientModel contains building blocks for communicating with cloud services. It provides shared primitives, abstractions, and helpers for .NET service client libraries. System.ClientModel allows client libraries built from its components to expose common functionality in a consistent fashion, so that once you learn how to use these APIs in one client library, you'll know how to use them in other client libraries as well. Source code | Package (NuGet) Getting started Typically, you will not need to install System.ClientModel. It will be installed for you when you install a client library that uses it. Install the package Install the client library for .NET with NuGet. dotnet add package System.ClientModel Prerequisites None needed for System.ClientModel. Key concepts System.ClientModel contains two major categories of types: (1) types used to author service clients, and (2) types exposed in the public APIs of clients built using System.ClientModel types. The latter are intended for use by the end-users of service clients to communicate with cloud services. Types used to author service clients appear in the System.ClientModel.Primitives namespace. Key concepts involving these types include: Client pipeline used to send and receive HTTP messages (ClientPipeline). Interfaces used to read and write input and output models exposed in client convenience APIs (IPersistableModel<T> and IJsonModel<T>). Service methods that end-users of clients call to invoke service operations fall into two categories: convenience methods and lower-level protocol methods. Types used in clients' convenience methods appear in the root System.ClientModel namespace. Types used in protocol methods and other lower-level scenarios appear in the System.ClientModel.Primitives namespace. Key concepts involving these types include: Results that provide access to the service response and the HTTP response details (ClientResult<T>, ClientResult). Exceptions that result from failed requests (ClientResultException). Options used to configure the service client pipeline (ClientPipelineOptions). Options used to customize HTTP requests (RequestOptions). Content sent in an HTTP request body (BinaryContent). Below, you will find sections explaining these shared concepts in more detail. Examples Send a message using ClientPipeline System.ClientModel-based clients, or service clients, use the ClientPipeline type to send and receive HTTP messages. The following sample shows a minimal example of what a service client implementation might look like. public class SampleClient { private readonly Uri _endpoint; private readonly ApiKeyCredential _credential; private readonly ClientPipeline _pipeline; // Constructor takes service endpoint, credential used to authenticate // with the service, and options for configuring the client pipeline. public SampleClient(Uri endpoint, ApiKeyCredential credential, SampleClientOptions? options = default) { // Default options are used if none are passed by the client's user. options ??= new SampleClientOptions(); _endpoint = endpoint; _credential = credential; // Authentication policy instance is created from the user-provided // credential and service authentication scheme. ApiKeyAuthenticationPolicy authenticationPolicy = ApiKeyAuthenticationPolicy.CreateBearerAuthorizationPolicy(credential); // Pipeline is created from user-provided options and policies // specific to the service client implementation. _pipeline = ClientPipeline.Create(options, perCallPolicies: ReadOnlySpan<PipelinePolicy>.Empty, perTryPolicies: new PipelinePolicy[] { authenticationPolicy }, beforeTransportPolicies: ReadOnlySpan<PipelinePolicy>.Empty); } // Service method takes an input model representing a service resource // and returns `ClientResult<T>` holding an output model representing // the value returned in the service response. public ClientResult<SampleResource> UpdateResource(SampleResource resource) { // Create a message that can be sent via the client pipeline. using PipelineMessage message = _pipeline.CreateMessage(); // Modify the request as needed to invoke the service operation. PipelineRequest request = message.Request; request.Method = \"PATCH\"; request.Uri = new Uri($\"https://www.example.com/update?id={resource.Id}\"); request.Headers.Add(\"Accept\", \"application/json\"); // Add request body content that will be written using methods // defined by the model's implementation of the IJsonModel<T> interface. request.Content = BinaryContent.Create(resource); // Send the message. _pipeline.Send(message); // Obtain the response from the message Response property. // The PipelineTransport ensures that the Response value is set // so that every policy in the pipeline can access the property. PipelineResponse response = message.Response!; // If the response is considered an error response, throw an // exception that exposes the response details. if (response.IsError) { throw new ClientResultException(response); } // Read the content from the response body and create an instance of // a model from it, to include in the type returned by this method. SampleResource updated = ModelReaderWriter.Read<SampleResource>(response.Content)!; // Return a ClientResult<T> holding the model instance and the HTTP // response details. return ClientResult.FromValue(updated, response); } } For more information on authoring clients, see Client implementation samples. Reading and writing model content to HTTP messages Service clients provide model types representing service resources as input parameters and return values from service clients' convenience methods. Client authors can implement the IPersistableModel<T> and IJsonModel<T> interfaces their in model implementations to make it easy for clients to write input model content to request message bodies, and to read response content and create instances of output models from it. An example of how clients' service methods might use such models is shown in Send a message using the ClientPipeline. The following sample shows a minimal example of what a persistable model implementation might look like. public class SampleResource : IJsonModel<SampleResource> { public SampleResource(string id) { Id = id; } public string Id { get; init; } SampleResource IJsonModel<SampleResource>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => FromJson(reader); SampleResource IPersistableModel<SampleResource>.Create(BinaryData data, ModelReaderWriterOptions options) => FromJson(new Utf8JsonReader(data)); string IPersistableModel<SampleResource>.GetFormatFromOptions(ModelReaderWriterOptions options) => options.Format; void IJsonModel<SampleResource>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ToJson(writer); BinaryData IPersistableModel<SampleResource>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write(this, options); // Write the model JSON that will populate the HTTP request content. private void ToJson(Utf8JsonWriter writer) { writer.WriteStartObject(); writer.WritePropertyName(\"id\"); writer.WriteStringValue(Id); writer.WriteEndObject(); } // Read the JSON response content and create a model instance from it. private static SampleResource FromJson(Utf8JsonReader reader) { reader.Read(); // start object reader.Read(); // property name reader.Read(); // id value return new SampleResource(reader.GetString()!); } } For more information on reading and writing persistable models, see Model reader writer samples. Accessing the service response Service clients have methods that are used to call cloud services to invoke service operations. These methods on a client are called service methods, and they send a request to the service and return a representation of its response to the caller. Service clients expose two types of service methods: convenience methods and protocol methods. Convenience methods provide a convenient way to invoke a service operation. They are methods that take a strongly-typed model as input and return a ClientResult<T> that holds a strongly-typed representation of the service response. Details from the HTTP response may also be obtained from the return value. Protocol method are low-level methods that take parameters that correspond to the service HTTP API and return a ClientResult holding only the raw HTTP response details. These methods also take an optional RequestOptions parameter that allows the client pipeline and the request to be configured for the duration of the call. The following sample illustrates how to call a convenience method and access the output model created from the service response. MapsClient client = new(new Uri(\"https://atlas.microsoft.com\"), credential); // Call a convenience method, which returns ClientResult<T> IPAddress ipAddress = IPAddress.Parse(\"2001:4898:80e8:b::189\"); ClientResult<IPAddressCountryPair> result = await client.GetCountryCodeAsync(ipAddress); // Access the output model from the service response. IPAddressCountryPair value = result.Value; Console.WriteLine($\"Country is {value.CountryRegion.IsoCode}.\"); If needed, callers can obtain the details of the HTTP response by calling the result's GetRawResponse method. // Access the HTTP response details. PipelineResponse response = result.GetRawResponse(); Console.WriteLine($\"Response status code: '{response.Status}'.\"); Console.WriteLine(\"Response headers:\"); foreach (KeyValuePair<string, string> header in response.Headers) { Console.WriteLine($\"Name: '{header.Key}', Value: '{header.Value}'.\"); } For more information on client service methods, see Client service method samples. Handling exceptions that result from failed requests When a service call fails, service clients throw a ClientResultException. The exception exposes the HTTP status code and the details of the service response if available. try { IPAddress ipAddress = IPAddress.Parse(\"2001:4898:80e8:b::189\"); ClientResult<IPAddressCountryPair> result = await client.GetCountryCodeAsync(ipAddress); } // Handle exception with status code 404 catch (ClientResultException e) when (e.Status == 404) { // Handle not found error Console.Error.WriteLine($\"Error: Response failed with status code: '{e.Status}'\"); } Whether or not a response is considered an error by the client is determined by the PipelineMessageClassifier held by a message when it is sent through the client pipeline. For more information on how client authors can customize error classification, see Configuring error response classification samples. Configuring service clients Service clients provide a constructor that takes a service endpoint and a credential used to authenticate with the service. They also provide a constructor overload that takes an endpoint, a credential, and an instance of ClientPipelineOptions. Passing ClientPipelineOptions when a client is created will configure the pipeline that the client uses to send and receive HTTP requests and responses. Client pipeline options can be used to override default values such as the network timeout used to send or retry a request. MapsClientOptions options = new() { NetworkTimeout = TimeSpan.FromSeconds(120), }; string? key = Environment.GetEnvironmentVariable(\"MAPS_API_KEY\"); ApiKeyCredential credential = new(key!); MapsClient client = new(new Uri(\"https://atlas.microsoft.com\"), credential, options); For more information on client configuration, see Client configuration samples. Customizing HTTP requests Service clients expose low-level protocol methods that allow callers to customize HTTP requests by passing an optional RequestOptions parameter. RequestOptions can be used to modify various aspects of the request sent by the service method, such as adding a request header, or adding a policy to the client pipeline that can modify the request directly before sending it to the service. RequestOptions also allows a client user to pass a CancellationToken to the method. // Create RequestOptions instance. RequestOptions options = new(); // Set the CancellationToken. options.CancellationToken = cancellationToken; // Add a header to the request. options.AddHeader(\"CustomHeader\", \"CustomHeaderValue\"); // Create an instance of a model that implements the IJsonModel<T> interface. CountryRegion region = new(\"US\"); // Create BinaryContent from the input model. BinaryContent content = BinaryContent.Create(region); // Call the protocol method, passing the content and options. ClientResult result = await client.AddCountryCodeAsync(content, options); For more information on customizing requests, see Protocol method samples. Provide request content In service clients' protocol methods, users pass the request content as a BinaryContent parameter. There are a variety of ways to create a BinaryContent instance: From BinaryData, which can be created from a string, a stream, an object, or from a byte array containing the serialized UTF-8 bytes From a model type that implements the IPersistableModel<T> or IJsonModel<T> interfaces. The following examples illustrate some of the different ways to create BinaryContent and pass it to a protocol method. From a string literal // Create a BinaryData instance from a JSON string literal. BinaryData input = BinaryData.FromString(\"\"\" { \"countryRegion\": { \"isoCode\": \"US\" }, } \"\"\"); // Create a BinaryContent instance to set as the HTTP request content. BinaryContent requestContent = BinaryContent.Create(input); // Call the protocol method. ClientResult result = await client.AddCountryCodeAsync(requestContent); // Obtain the output response content from the returned ClientResult. BinaryData output = result.GetRawResponse().Content; using JsonDocument outputAsJson = JsonDocument.Parse(output.ToString()); string isoCode = outputAsJson.RootElement .GetProperty(\"countryRegion\") .GetProperty(\"isoCode\") .GetString(); Console.WriteLine($\"Code for added country is '{isoCode}'.\"); From an anonymous type // Create a BinaryData instance from an anonymous object representing // the JSON the service expects for the service operation. BinaryData input = BinaryData.FromObjectAsJson(new { countryRegion = new { isoCode = \"US\" } }); // Create the BinaryContent instance to pass to the protocol method. BinaryContent content = BinaryContent.Create(input); // Call the protocol method. ClientResult result = await client.AddCountryCodeAsync(content); From an input stream // Create a BinaryData instance from a file stream FileStream stream = File.OpenRead(@\"c:\\path\\to\\file.txt\"); BinaryData input = BinaryData.FromStream(stream); // Create the BinaryContent instance to pass to the protocol method. BinaryContent content = BinaryContent.Create(input); // Call the protocol method. ClientResult result = await client.AddCountryCodeAsync(content); From a model type // Create an instance of a model that implements the IJsonModel<T> interface. CountryRegion region = new(\"US\"); // Create BinaryContent from the input model. BinaryContent content = BinaryContent.Create(region); // Call the protocol method, passing the content and options. ClientResult result = await client.AddCountryCodeAsync(content); Troubleshooting You can troubleshoot service clients by inspecting the result of any ClientResultException thrown from a client's service method. For more information on client service method errors, see Handling exceptions that result from failed requests. Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com. When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repositories using our CLA. This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments."
  },
  "packages/System.Configuration.ConfigurationManager.10.0.0/PACKAGE.html": {
    "href": "packages/System.Configuration.ConfigurationManager.10.0.0/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Provides types that support using XML configuration files (app.config). This package exists only to support migrating existing .NET Framework code that already uses System.Configuration. When writing new code, use another configuration system instead, such as Microsoft.Extensions.Configuration. How to Use The following example shows how to read and modify the application configuration settings. using System; using System.Configuration; class Program { static void Main() { try { // Open current application configuration Configuration config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); KeyValueConfigurationCollection section = config.AppSettings.Settings; // Print settings from configuration file foreach (string key in section.AllKeys) { Console.WriteLine($\"{key}: {section[key].Value}\"); } // Add new setting section.Add(\"Database\", \"TestDatabase\"); // Change existing setting section[\"Username\"].Value = \"TestUser\"; // Save changes to file config.Save(ConfigurationSaveMode.Modified); ConfigurationManager.RefreshSection(config.AppSettings.SectionInformation.Name); } catch (ConfigurationErrorsException ex) { Console.WriteLine(\"Error reading configuration: \"); Console.WriteLine(ex.Message); } } } To run this example, include an app.config file with the following content in your project: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key=\"Server\" value=\"example.com\"/> <add key=\"Username\" value=\"Admin\"/> </appSettings> </configuration> Main Types The main types provided by this library are: System.Configuration.Configuration System.Configuration.ConfigurationManager Additional Documentation Configure apps by using configuration files System.Configuration namespace System.Configuration.Configuration System.Configuration.ConfigurationManager Feedback & Contributing System.Configuration.ConfigurationManager is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/System.Memory.Data.8.0.1/PACKAGE.html": {
    "href": "packages/System.Memory.Data.8.0.1/PACKAGE.html",
    "title": "| mysite",
    "summary": "About System.Memory.Data introduces the BinaryData type, a lightweight abstraction for a byte payload. It makes it easy to convert between string, bytes, and stream. This abstraction can simplify the API surface by exposing a single type instead of numerous overloads or properties. The BinaryData type handles data ownership efficiently, wrapping passed-in bytes when using byte[] or ReadOnlyMemory<byte> constructors or methods, and managing data as bytes when dealing with streams, strings, or rich model types serialized as JSON. Key Features Lightweight abstraction for byte payload via BinaryData type. Convenient helper methods for common conversions among string, bytes, and stream. Efficient data ownership handling. How to Use To/From String: var data = new BinaryData(\"some data\"); // ToString will decode the bytes using UTF-8 Console.WriteLine(data.ToString()); // prints \"some data\" To/From Bytes: byte[] bytes = Encoding.UTF8.GetBytes(\"some data\"); // Create BinaryData using a constructor ... BinaryData data = new BinaryData(bytes); // Or using a static factory method. data = BinaryData.FromBytes(bytes); // There is an implicit cast defined for ReadOnlyMemory<byte> ReadOnlyMemory<byte> rom = data; // There is also an implicit cast defined for ReadOnlySpan<byte> ReadOnlySpan<byte> ros = data; // there is also a ToMemory method that gives access to the ReadOnlyMemory. rom = data.ToMemory(); // and a ToArray method that converts into a byte array. byte[] array = data.ToArray(); To/From stream: var bytes = Encoding.UTF8.GetBytes(\"some data\"); Stream stream = new MemoryStream(bytes); var data = BinaryData.FromStream(stream); // Calling ToStream will give back a stream that is backed by ReadOnlyMemory, so it is not writable. stream = data.ToStream(); Console.WriteLine(stream.CanWrite); // prints false BinaryData also can be used to integrate with ObjectSerializer. By default, the JsonObjectSerializer will be used, but any serializer deriving from ObjectSerializer can be used. var model = new CustomModel { A = \"some text\", B = 5, C = true }; var data = BinaryData.FromObjectAsJson(model); model = data.ToObjectFromJson<CustomModel>(); Main Types The main types provided by this library are: System.BinaryData Additional Documentation API documentation Feedback & Contributing System.Memory.Data is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "packages/System.Text.Json.8.0.5/PACKAGE.html": {
    "href": "packages/System.Text.Json.8.0.5/PACKAGE.html",
    "title": "| mysite",
    "summary": "About Provides high-performance and low-allocating types that serialize objects to JavaScript Object Notation (JSON) text and deserialize JSON text to objects, with UTF-8 support built-in. Also provides types to read and write JSON text encoded as UTF-8, and to create an in-memory document object model (DOM), that is read-only, for random access of the JSON elements within a structured view of the data. Key Features High-performance reader and writer types for UTF-8 encoded JSON. A fully-featured JSON serializer for .NET types using reflection or source generated contracts. A high-performance read-only JSON DOM (JsonDocument) and a mutable DOM that interoperates with the serializer (JsonNode). Built-in support for async serialization, including IAsyncEnumerable support. Fully customizable contract model for serializable types. How to Use The System.Text.Json library is built-in as part of the shared framework in .NET Runtime. The package can be installed when you need to use the most recent version in older target frameworks. Serialization: using System; using System.Text.Json; WeatherForecast forecast = new (DateTimeOffset.Now, 26.6f, \"Sunny\"); var serialized = JsonSerializer.Serialize(forecast); Console.WriteLine(serialized); // {\"Date\":\"2023-08-02T16:01:20.9025406+00:00\",\"TemperatureCelsius\":26.6,\"Summary\":\"Sunny\"} var forecastDeserialized = JsonSerializer.Deserialize<WeatherForecast>(serialized); Console.WriteLine(forecast == forecastDeserialized); // True public record WeatherForecast(DateTimeOffset Date, float TemperatureCelsius, string? Summary); Serialization using the source generator: using System.Text.Json; using System.Text.Json.Serialization; WeatherForecast forecast = new (DateTimeOffset.Now, 26.6f, \"Sunny\"); var serialized = JsonSerializer.Serialize(forecast, SourceGenerationContext.Default.WeatherForecast); Console.WriteLine(serialized); // {\"Date\":\"2023-08-02T16:01:20.9025406+00:00\",\"TemperatureCelsius\":26.6,\"Summary\":\"Sunny\"} var forecastDeserialized = JsonSerializer.Deserialize<WeatherForecast>(serialized, SourceGenerationContext.Default.WeatherForecast); Console.WriteLine(forecast == forecastDeserialized); // True public record WeatherForecast(DateTimeOffset Date, float TemperatureCelsius, string? Summary); [JsonSourceGenerationOptions(WriteIndented = true)] [JsonSerializable(typeof(WeatherForecast))] internal partial class SourceGenerationContext : JsonSerializerContext { } Using the JSON DOM: using System; using System.Text.Json; using System.Text.Json.Nodes; string jsonString = @\"{ \"\"Date\"\": \"\"2019-08-01T00:00:00\"\", \"\"Temperature\"\": 25, \"\"Summary\"\": \"\"Hot\"\", \"\"DatesAvailable\"\": [ \"\"2019-08-01T00:00:00\"\", \"\"2019-08-02T00:00:00\"\" ], \"\"TemperatureRanges\"\": { \"\"Cold\"\": { \"\"High\"\": 20, \"\"Low\"\": -10 }, \"\"Hot\"\": { \"\"High\"\": 60, \"\"Low\"\": 20 } } } \"; JsonNode forecastNode = JsonNode.Parse(jsonString)!; // Get value from a JsonNode. JsonNode temperatureNode = forecastNode[\"Temperature\"]!; Console.WriteLine($\"Type={temperatureNode.GetType()}\"); Console.WriteLine($\"JSON={temperatureNode.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonValue`1[System.Text.Json.JsonElement] //JSON = 25 // Get a typed value from a JsonNode. int temperatureInt = (int)forecastNode[\"Temperature\"]!; Console.WriteLine($\"Value={temperatureInt}\"); //output: //Value=25 // Get a typed value from a JsonNode by using GetValue<T>. temperatureInt = forecastNode[\"Temperature\"]!.GetValue<int>(); Console.WriteLine($\"TemperatureInt={temperatureInt}\"); //output: //Value=25 // Get a JSON object from a JsonNode. JsonNode temperatureRanges = forecastNode[\"TemperatureRanges\"]!; Console.WriteLine($\"Type={temperatureRanges.GetType()}\"); Console.WriteLine($\"JSON={temperatureRanges.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonObject //JSON = { \"Cold\":{ \"High\":20,\"Low\":-10},\"Hot\":{ \"High\":60,\"Low\":20} } // Get a JSON array from a JsonNode. JsonNode datesAvailable = forecastNode[\"DatesAvailable\"]!; Console.WriteLine($\"Type={datesAvailable.GetType()}\"); Console.WriteLine($\"JSON={datesAvailable.ToJsonString()}\"); //output: //datesAvailable Type = System.Text.Json.Nodes.JsonArray //datesAvailable JSON =[\"2019-08-01T00:00:00\", \"2019-08-02T00:00:00\"] // Get an array element value from a JsonArray. JsonNode firstDateAvailable = datesAvailable[0]!; Console.WriteLine($\"Type={firstDateAvailable.GetType()}\"); Console.WriteLine($\"JSON={firstDateAvailable.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonValue`1[System.Text.Json.JsonElement] //JSON = \"2019-08-01T00:00:00\" // Get a typed value by chaining references. int coldHighTemperature = (int)forecastNode[\"TemperatureRanges\"]![\"Cold\"]![\"High\"]!; Console.WriteLine($\"TemperatureRanges.Cold.High={coldHighTemperature}\"); //output: //TemperatureRanges.Cold.High = 20 // Parse a JSON array JsonNode datesNode = JsonNode.Parse(@\"[\"\"2019-08-01T00:00:00\"\",\"\"2019-08-02T00:00:00\"\"]\")!; JsonNode firstDate = datesNode[0]!.GetValue<DateTime>(); Console.WriteLine($\"firstDate={ firstDate}\"); //output: //firstDate = \"2019-08-01T00:00:00\" Using the low-level JSON reader/writer types using System; using System.IO; using System.Text; using System.Text.Json; var writerOptions = new JsonWriterOptions { Indented = true }; using var stream = new MemoryStream(); using var writer = new Utf8JsonWriter(stream, writerOptions); writer.WriteStartObject(); writer.WriteString(\"date\", DateTimeOffset.Parse(\"8/2/2023 9:00 AM\")); writer.WriteNumber(\"temp\", 42); writer.WriteEndObject(); writer.Flush(); var jsonBytes = stream.ToArray(); string json = Encoding.UTF8.GetString(jsonBytes); Console.WriteLine(json); // { // \"date\": \"2023-08-02T09:00:00+00:00\" // \"temp\": 42 // } var readerOptions = new JsonReaderOptions { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip }; var reader = new Utf8JsonReader(jsonBytes, readerOptions); while (reader.Read()) { Console.Write(reader.TokenType); switch (reader.TokenType) { case JsonTokenType.PropertyName: case JsonTokenType.String: { string? text = reader.GetString(); Console.Write(\" \"); Console.Write(text); break; } case JsonTokenType.Number: { int intValue = reader.GetInt32(); Console.Write(\" \"); Console.Write(intValue); break; } // Other token types elided for brevity } Console.WriteLine(); } // StartObject // PropertyName date // String 2023-08-02T09:00:00+00:00 // PropertyName temp // Number 42 // EndObject Main Types The main types provided by this library are: System.Text.Json.Utf8JsonWriter System.Text.Json.Utf8JsonReader System.Text.Json.JsonSerializer System.Text.Json.JsonConverter System.Text.Json.JsonDocument System.Text.Json.Nodes.JsonNode System.Text.Json.Serialization.Metadata.JsonTypeInfo Additional Documentation Conceptual documentation API documentation Related Packages Lightweight data formats abstraction: System.Memory.Data Serialization of HttpContent: System.Net.Http.Json Feedback & Contributing System.Text.Json is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  }
}